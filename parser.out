Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    QUOTE

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID initProg SCOLON declarClases declarVar addGlobSize definFunc MAIN auxMain LPAREN RPAREN declarVar LBRACE listaEstatutos RBRACE endProg prueba
Rule 2     addGlobSize -> <empty>
Rule 3     initProg -> <empty>
Rule 4     auxMain -> <empty>
Rule 5     endProg -> <empty>
Rule 6     declarClases -> CLASS ID herencia LBRACE ATTRIBUTES declarAttributes METHODS declarMethods RBRACE declarClases
Rule 7     declarClases -> empty
Rule 8     herencia -> LT EXTENDS ID GT
Rule 9     herencia -> empty
Rule 10    declarAttributes -> tipo COLON listaIdDeclare SCOLON declarAttributes
Rule 11    declarAttributes -> empty
Rule 12    listaIdDeclare -> idDeclare
Rule 13    listaIdDeclare -> idDeclare COMMA listaIdDeclare
Rule 14    idDeclare -> ID auxDeclare auxDeclare2
Rule 15    idDeclare -> ID auxDeclare LBRACK CTE_I addCteTable RBRACK auxCTE
Rule 16    idDeclare -> ID auxDeclare LBRACK CTE_I addCteTable COMMA CTE_I addCteTable auxCTE2 RBRACK
Rule 17    auxDeclare -> <empty>
Rule 18    auxDeclare2 -> <empty>
Rule 19    auxCTE -> <empty>
Rule 20    auxCTE2 -> <empty>
Rule 21    idCall -> ID idCallaux checkDim
Rule 22    idCall -> ID idCallaux DOT ID
Rule 23    idCall -> ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
Rule 24    idCall -> ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2
Rule 25    idCallaux -> <empty>
Rule 26    idCallaux2 -> <empty>
Rule 27    idCallaux3 -> <empty>
Rule 28    idCallaux4 -> <empty>
Rule 29    checkDim -> <empty>
Rule 30    checkDim1 -> <empty>
Rule 31    checkDim2 -> <empty>
Rule 32    tipo -> ID
Rule 33    tipo -> INT
Rule 34    tipo -> FLOAT
Rule 35    tipo -> CHAR
Rule 36    tipoMethod -> VOID
Rule 37    tipoMethod -> INT
Rule 38    tipoMethod -> FLOAT
Rule 39    tipoMethod -> CHAR
Rule 40    declarMethods -> tipoMethod FUNC ID LPAREN listaParam RPAREN LBRACE listaEstatutos RBRACE declarMethods
Rule 41    declarMethods -> empty
Rule 42    listaParam -> param
Rule 43    listaParam -> param COMMA listaParam
Rule 44    listaParam -> empty
Rule 45    param -> tipo COLON ID
Rule 46    declarVar -> VAR tipo COLON listaIdDeclare SCOLON declarVar
Rule 47    declarVar -> empty
Rule 48    definFunc -> tipoMethod FUNC ID auxFuncion LPAREN listaParam RPAREN declarVar setDI LBRACE listaEstatutos RBRACE endF definFunc
Rule 49    definFunc -> empty
Rule 50    auxFuncion -> <empty>
Rule 51    setDI -> <empty>
Rule 52    endF -> <empty>
Rule 53    listaEstatutos -> estatutos listaEstatutos
Rule 54    listaEstatutos -> empty
Rule 55    estatutos -> llamada SCOLON
Rule 56    estatutos -> asignacion SCOLON
Rule 57    estatutos -> returnf SCOLON
Rule 58    estatutos -> lectura SCOLON
Rule 59    estatutos -> escritura SCOLON
Rule 60    estatutos -> condicion
Rule 61    estatutos -> cond_w
Rule 62    estatutos -> cond_f
Rule 63    asignacion -> idCall ASIGNA pushPoper exp asignStep2
Rule 64    asignStep2 -> <empty>
Rule 65    llamada -> ID DOT ID LPAREN enviaParam RPAREN
Rule 66    llamada -> ID verExist LPAREN enviaParam coherenceGo RPAREN
Rule 67    enviaParam -> paramReferencia
Rule 68    enviaParam -> empty
Rule 69    paramReferencia -> exp paramType
Rule 70    paramReferencia -> exp paramType COMMA paramCount paramReferencia
Rule 71    verExist -> <empty>
Rule 72    paramType -> <empty>
Rule 73    paramCount -> <empty>
Rule 74    coherenceGo -> <empty>
Rule 75    returnf -> RETURN pushPoper LPAREN exp RPAREN popReturn
Rule 76    popReturn -> <empty>
Rule 77    lectura -> READ pushPoper LPAREN listaId RPAREN
Rule 78    listaId -> idCall popIO
Rule 79    listaId -> idCall COMMA popIO insertOpRead listaId
Rule 80    insertOpRead -> <empty>
Rule 81    popIO -> <empty>
Rule 82    escritura -> WRITE pushPoper LPAREN exp popIO lextra RPAREN
Rule 83    escritura -> WRITE pushPoper LPAREN LETRERO letreroPush popIO lextra RPAREN
Rule 84    lextra -> COMMA insertOpWrite exp popIO lextra
Rule 85    lextra -> COMMA insertOpWrite LETRERO letreroPush popIO lextra
Rule 86    lextra -> empty
Rule 87    insertOpWrite -> <empty>
Rule 88    letreroPush -> <empty>
Rule 89    condicion -> IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE
Rule 90    condicion -> IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE ELSE cond3 LBRACE listaEstatutos RBRACE
Rule 91    cond1 -> <empty>
Rule 92    cond3 -> <empty>
Rule 93    cond_w -> WHILE step1While LPAREN exp RPAREN step2While DO LBRACE listaEstatutos RBRACE step3While
Rule 94    step1While -> <empty>
Rule 95    step2While -> <empty>
Rule 96    step3While -> <empty>
Rule 97    cond_f -> FOR asignacion TO exp step1While step1For step2While DO LBRACE listaEstatutos RBRACE step3While
Rule 98    step1For -> <empty>
Rule 99    exp -> texp step7
Rule 100   exp -> texp step7 OR pushPoper exp
Rule 101   texp -> gexp step6
Rule 102   texp -> gexp step6 AND pushPoper texp
Rule 103   gexp -> mexp step5
Rule 104   gexp -> mexp step5 LT pushPoper gexp
Rule 105   gexp -> mexp step5 GT pushPoper gexp
Rule 106   gexp -> mexp step5 LTE pushPoper gexp
Rule 107   gexp -> mexp step5 GTE pushPoper gexp
Rule 108   gexp -> mexp step5 EQUALS pushPoper gexp
Rule 109   gexp -> mexp step5 NEQUALS pushPoper gexp
Rule 110   mexp -> t step4
Rule 111   mexp -> t step4 PLUS pushPoper mexp
Rule 112   mexp -> t step4 MINUS pushPoper mexp
Rule 113   t -> f step3
Rule 114   t -> f step3 MULT pushPoper t
Rule 115   t -> f step3 DIV pushPoper t
Rule 116   f -> LPAREN addFF exp RPAREN rmFF
Rule 117   f -> CTE_I addCteTable step1
Rule 118   f -> CTE_F addCteTable step1
Rule 119   f -> CTE_C addCteTable step1
Rule 120   f -> llamada
Rule 121   f -> idCall
Rule 122   addCteTable -> <empty>
Rule 123   step1 -> <empty>
Rule 124   step3 -> <empty>
Rule 125   step4 -> <empty>
Rule 126   step5 -> <empty>
Rule 127   step6 -> <empty>
Rule 128   step7 -> <empty>
Rule 129   addFF -> <empty>
Rule 130   rmFF -> <empty>
Rule 131   pushPoper -> <empty>
Rule 132   empty -> <empty>
Rule 133   prueba -> <empty>

Terminals, with rules where they appear

AND                  : 102
ASIGNA               : 63
ATTRIBUTES           : 6
CHAR                 : 35 39
CLASS                : 6
COLON                : 10 45 46
COMMA                : 13 16 24 43 70 79 84 85
CTE_C                : 119
CTE_F                : 118
CTE_I                : 15 16 16 117
DIV                  : 115
DO                   : 93 97
DOT                  : 22 65
ELSE                 : 90
EQUALS               : 108
EXTENDS              : 8
FLOAT                : 34 38
FOR                  : 97
FUNC                 : 40 48
GT                   : 8 105
GTE                  : 107
ID                   : 1 6 8 14 15 16 21 22 22 23 24 32 40 45 48 65 65 66
IF                   : 89 90
INT                  : 33 37
LBRACE               : 1 6 40 48 89 90 90 93 97
LBRACK               : 15 16 23 24
LETRERO              : 83 85
LPAREN               : 1 40 48 65 66 75 77 82 83 89 90 93 116
LT                   : 8 104
LTE                  : 106
MAIN                 : 1
METHODS              : 6
MINUS                : 112
MULT                 : 114
NEQUALS              : 109
OR                   : 100
PLUS                 : 111
PROGRAM              : 1
QUOTE                : 
RBRACE               : 1 6 40 48 89 90 90 93 97
RBRACK               : 15 16 23 24
READ                 : 77
RETURN               : 75
RPAREN               : 1 40 48 65 66 75 77 82 83 89 90 93 116
SCOLON               : 1 10 46 55 56 57 58 59
THEN                 : 89 90
TO                   : 97
VAR                  : 46
VOID                 : 36
WHILE                : 93
WRITE                : 82 83
error                : 

Nonterminals, with rules where they appear

addCteTable          : 15 16 16 117 118 119
addFF                : 23 24 24 116
addGlobSize          : 1
asignStep2           : 63
asignacion           : 56 97
auxCTE               : 15
auxCTE2              : 16
auxDeclare           : 14 15 16
auxDeclare2          : 14
auxFuncion           : 48
auxMain              : 1
checkDim             : 21
checkDim1            : 23
checkDim2            : 24
coherenceGo          : 66
cond1                : 89 90
cond3                : 90
cond_f               : 62
cond_w               : 61
condicion            : 60
declarAttributes     : 6 10
declarClases         : 1 6
declarMethods        : 6 40
declarVar            : 1 1 46 48
definFunc            : 1 48
empty                : 7 9 11 41 44 47 49 54 68 86
endF                 : 48
endProg              : 1
enviaParam           : 65 66
escritura            : 59
estatutos            : 53
exp                  : 23 24 24 63 69 70 75 82 84 89 90 93 97 100 116
f                    : 113 114 115
gexp                 : 101 102 104 105 106 107 108 109
herencia             : 6
idCall               : 63 78 79 121
idCallaux            : 21 22 23 24
idCallaux2           : 24
idCallaux3           : 24
idCallaux4           : 23
idDeclare            : 12 13
initProg             : 1
insertOpRead         : 79
insertOpWrite        : 84 85
lectura              : 58
letreroPush          : 83 85
lextra               : 82 83 84 85
listaEstatutos       : 1 40 48 53 89 90 90 93 97
listaId              : 77 79
listaIdDeclare       : 10 13 46
listaParam           : 40 43 48
llamada              : 55 120
mexp                 : 103 104 105 106 107 108 109 111 112
param                : 42 43
paramCount           : 70
paramReferencia      : 67 70
paramType            : 69 70
popIO                : 78 79 82 83 84 85
popReturn            : 75
program              : 0
prueba               : 1
pushPoper            : 63 75 77 82 83 100 102 104 105 106 107 108 109 111 112 114 115
returnf              : 57
rmFF                 : 23 24 24 116
setDI                : 48
step1                : 117 118 119
step1For             : 97
step1While           : 93 97
step2While           : 93 97
step3                : 113 114 115
step3While           : 93 97
step4                : 110 111 112
step5                : 103 104 105 106 107 108 109
step6                : 101 102
step7                : 99 100
t                    : 110 111 112 114 115
texp                 : 99 100 102
tipo                 : 10 45 46
tipoMethod           : 40 48
verExist             : 66

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID initProg SCOLON declarClases declarVar addGlobSize definFunc MAIN auxMain LPAREN RPAREN declarVar LBRACE listaEstatutos RBRACE endProg prueba

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID initProg SCOLON declarClases declarVar addGlobSize definFunc MAIN auxMain LPAREN RPAREN declarVar LBRACE listaEstatutos RBRACE endProg prueba

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . initProg SCOLON declarClases declarVar addGlobSize definFunc MAIN auxMain LPAREN RPAREN declarVar LBRACE listaEstatutos RBRACE endProg prueba
    (3) initProg -> .

    SCOLON          reduce using rule 3 (initProg -> .)

    initProg                       shift and go to state 4

state 4

    (1) program -> PROGRAM ID initProg . SCOLON declarClases declarVar addGlobSize definFunc MAIN auxMain LPAREN RPAREN declarVar LBRACE listaEstatutos RBRACE endProg prueba

    SCOLON          shift and go to state 5


state 5

    (1) program -> PROGRAM ID initProg SCOLON . declarClases declarVar addGlobSize definFunc MAIN auxMain LPAREN RPAREN declarVar LBRACE listaEstatutos RBRACE endProg prueba
    (6) declarClases -> . CLASS ID herencia LBRACE ATTRIBUTES declarAttributes METHODS declarMethods RBRACE declarClases
    (7) declarClases -> . empty
    (132) empty -> .

    CLASS           shift and go to state 7
    VAR             reduce using rule 132 (empty -> .)
    VOID            reduce using rule 132 (empty -> .)
    INT             reduce using rule 132 (empty -> .)
    FLOAT           reduce using rule 132 (empty -> .)
    CHAR            reduce using rule 132 (empty -> .)
    MAIN            reduce using rule 132 (empty -> .)

    declarClases                   shift and go to state 6
    empty                          shift and go to state 8

state 6

    (1) program -> PROGRAM ID initProg SCOLON declarClases . declarVar addGlobSize definFunc MAIN auxMain LPAREN RPAREN declarVar LBRACE listaEstatutos RBRACE endProg prueba
    (46) declarVar -> . VAR tipo COLON listaIdDeclare SCOLON declarVar
    (47) declarVar -> . empty
    (132) empty -> .

    VAR             shift and go to state 10
    VOID            reduce using rule 132 (empty -> .)
    INT             reduce using rule 132 (empty -> .)
    FLOAT           reduce using rule 132 (empty -> .)
    CHAR            reduce using rule 132 (empty -> .)
    MAIN            reduce using rule 132 (empty -> .)

    declarVar                      shift and go to state 9
    empty                          shift and go to state 11

state 7

    (6) declarClases -> CLASS . ID herencia LBRACE ATTRIBUTES declarAttributes METHODS declarMethods RBRACE declarClases

    ID              shift and go to state 12


state 8

    (7) declarClases -> empty .

    VAR             reduce using rule 7 (declarClases -> empty .)
    VOID            reduce using rule 7 (declarClases -> empty .)
    INT             reduce using rule 7 (declarClases -> empty .)
    FLOAT           reduce using rule 7 (declarClases -> empty .)
    CHAR            reduce using rule 7 (declarClases -> empty .)
    MAIN            reduce using rule 7 (declarClases -> empty .)


state 9

    (1) program -> PROGRAM ID initProg SCOLON declarClases declarVar . addGlobSize definFunc MAIN auxMain LPAREN RPAREN declarVar LBRACE listaEstatutos RBRACE endProg prueba
    (2) addGlobSize -> .

    VOID            reduce using rule 2 (addGlobSize -> .)
    INT             reduce using rule 2 (addGlobSize -> .)
    FLOAT           reduce using rule 2 (addGlobSize -> .)
    CHAR            reduce using rule 2 (addGlobSize -> .)
    MAIN            reduce using rule 2 (addGlobSize -> .)

    addGlobSize                    shift and go to state 13

state 10

    (46) declarVar -> VAR . tipo COLON listaIdDeclare SCOLON declarVar
    (32) tipo -> . ID
    (33) tipo -> . INT
    (34) tipo -> . FLOAT
    (35) tipo -> . CHAR

    ID              shift and go to state 15
    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    CHAR            shift and go to state 18

    tipo                           shift and go to state 14

state 11

    (47) declarVar -> empty .

    VOID            reduce using rule 47 (declarVar -> empty .)
    INT             reduce using rule 47 (declarVar -> empty .)
    FLOAT           reduce using rule 47 (declarVar -> empty .)
    CHAR            reduce using rule 47 (declarVar -> empty .)
    MAIN            reduce using rule 47 (declarVar -> empty .)
    LBRACE          reduce using rule 47 (declarVar -> empty .)


state 12

    (6) declarClases -> CLASS ID . herencia LBRACE ATTRIBUTES declarAttributes METHODS declarMethods RBRACE declarClases
    (8) herencia -> . LT EXTENDS ID GT
    (9) herencia -> . empty
    (132) empty -> .

    LT              shift and go to state 20
    LBRACE          reduce using rule 132 (empty -> .)

    herencia                       shift and go to state 19
    empty                          shift and go to state 21

state 13

    (1) program -> PROGRAM ID initProg SCOLON declarClases declarVar addGlobSize . definFunc MAIN auxMain LPAREN RPAREN declarVar LBRACE listaEstatutos RBRACE endProg prueba
    (48) definFunc -> . tipoMethod FUNC ID auxFuncion LPAREN listaParam RPAREN declarVar setDI LBRACE listaEstatutos RBRACE endF definFunc
    (49) definFunc -> . empty
    (36) tipoMethod -> . VOID
    (37) tipoMethod -> . INT
    (38) tipoMethod -> . FLOAT
    (39) tipoMethod -> . CHAR
    (132) empty -> .

    VOID            shift and go to state 25
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    CHAR            shift and go to state 28
    MAIN            reduce using rule 132 (empty -> .)

    definFunc                      shift and go to state 22
    tipoMethod                     shift and go to state 23
    empty                          shift and go to state 24

state 14

    (46) declarVar -> VAR tipo . COLON listaIdDeclare SCOLON declarVar

    COLON           shift and go to state 29


state 15

    (32) tipo -> ID .

    COLON           reduce using rule 32 (tipo -> ID .)


state 16

    (33) tipo -> INT .

    COLON           reduce using rule 33 (tipo -> INT .)


state 17

    (34) tipo -> FLOAT .

    COLON           reduce using rule 34 (tipo -> FLOAT .)


state 18

    (35) tipo -> CHAR .

    COLON           reduce using rule 35 (tipo -> CHAR .)


state 19

    (6) declarClases -> CLASS ID herencia . LBRACE ATTRIBUTES declarAttributes METHODS declarMethods RBRACE declarClases

    LBRACE          shift and go to state 30


state 20

    (8) herencia -> LT . EXTENDS ID GT

    EXTENDS         shift and go to state 31


state 21

    (9) herencia -> empty .

    LBRACE          reduce using rule 9 (herencia -> empty .)


state 22

    (1) program -> PROGRAM ID initProg SCOLON declarClases declarVar addGlobSize definFunc . MAIN auxMain LPAREN RPAREN declarVar LBRACE listaEstatutos RBRACE endProg prueba

    MAIN            shift and go to state 32


state 23

    (48) definFunc -> tipoMethod . FUNC ID auxFuncion LPAREN listaParam RPAREN declarVar setDI LBRACE listaEstatutos RBRACE endF definFunc

    FUNC            shift and go to state 33


state 24

    (49) definFunc -> empty .

    MAIN            reduce using rule 49 (definFunc -> empty .)


state 25

    (36) tipoMethod -> VOID .

    FUNC            reduce using rule 36 (tipoMethod -> VOID .)


state 26

    (37) tipoMethod -> INT .

    FUNC            reduce using rule 37 (tipoMethod -> INT .)


state 27

    (38) tipoMethod -> FLOAT .

    FUNC            reduce using rule 38 (tipoMethod -> FLOAT .)


state 28

    (39) tipoMethod -> CHAR .

    FUNC            reduce using rule 39 (tipoMethod -> CHAR .)


state 29

    (46) declarVar -> VAR tipo COLON . listaIdDeclare SCOLON declarVar
    (12) listaIdDeclare -> . idDeclare
    (13) listaIdDeclare -> . idDeclare COMMA listaIdDeclare
    (14) idDeclare -> . ID auxDeclare auxDeclare2
    (15) idDeclare -> . ID auxDeclare LBRACK CTE_I addCteTable RBRACK auxCTE
    (16) idDeclare -> . ID auxDeclare LBRACK CTE_I addCteTable COMMA CTE_I addCteTable auxCTE2 RBRACK

    ID              shift and go to state 36

    listaIdDeclare                 shift and go to state 34
    idDeclare                      shift and go to state 35

state 30

    (6) declarClases -> CLASS ID herencia LBRACE . ATTRIBUTES declarAttributes METHODS declarMethods RBRACE declarClases

    ATTRIBUTES      shift and go to state 37


state 31

    (8) herencia -> LT EXTENDS . ID GT

    ID              shift and go to state 38


state 32

    (1) program -> PROGRAM ID initProg SCOLON declarClases declarVar addGlobSize definFunc MAIN . auxMain LPAREN RPAREN declarVar LBRACE listaEstatutos RBRACE endProg prueba
    (4) auxMain -> .

    LPAREN          reduce using rule 4 (auxMain -> .)

    auxMain                        shift and go to state 39

state 33

    (48) definFunc -> tipoMethod FUNC . ID auxFuncion LPAREN listaParam RPAREN declarVar setDI LBRACE listaEstatutos RBRACE endF definFunc

    ID              shift and go to state 40


state 34

    (46) declarVar -> VAR tipo COLON listaIdDeclare . SCOLON declarVar

    SCOLON          shift and go to state 41


state 35

    (12) listaIdDeclare -> idDeclare .
    (13) listaIdDeclare -> idDeclare . COMMA listaIdDeclare

    SCOLON          reduce using rule 12 (listaIdDeclare -> idDeclare .)
    COMMA           shift and go to state 42


state 36

    (14) idDeclare -> ID . auxDeclare auxDeclare2
    (15) idDeclare -> ID . auxDeclare LBRACK CTE_I addCteTable RBRACK auxCTE
    (16) idDeclare -> ID . auxDeclare LBRACK CTE_I addCteTable COMMA CTE_I addCteTable auxCTE2 RBRACK
    (17) auxDeclare -> .

    LBRACK          reduce using rule 17 (auxDeclare -> .)
    COMMA           reduce using rule 17 (auxDeclare -> .)
    SCOLON          reduce using rule 17 (auxDeclare -> .)

    auxDeclare                     shift and go to state 43

state 37

    (6) declarClases -> CLASS ID herencia LBRACE ATTRIBUTES . declarAttributes METHODS declarMethods RBRACE declarClases
    (10) declarAttributes -> . tipo COLON listaIdDeclare SCOLON declarAttributes
    (11) declarAttributes -> . empty
    (32) tipo -> . ID
    (33) tipo -> . INT
    (34) tipo -> . FLOAT
    (35) tipo -> . CHAR
    (132) empty -> .

    ID              shift and go to state 15
    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    CHAR            shift and go to state 18
    METHODS         reduce using rule 132 (empty -> .)

    declarAttributes               shift and go to state 44
    tipo                           shift and go to state 45
    empty                          shift and go to state 46

state 38

    (8) herencia -> LT EXTENDS ID . GT

    GT              shift and go to state 47


state 39

    (1) program -> PROGRAM ID initProg SCOLON declarClases declarVar addGlobSize definFunc MAIN auxMain . LPAREN RPAREN declarVar LBRACE listaEstatutos RBRACE endProg prueba

    LPAREN          shift and go to state 48


state 40

    (48) definFunc -> tipoMethod FUNC ID . auxFuncion LPAREN listaParam RPAREN declarVar setDI LBRACE listaEstatutos RBRACE endF definFunc
    (50) auxFuncion -> .

    LPAREN          reduce using rule 50 (auxFuncion -> .)

    auxFuncion                     shift and go to state 49

state 41

    (46) declarVar -> VAR tipo COLON listaIdDeclare SCOLON . declarVar
    (46) declarVar -> . VAR tipo COLON listaIdDeclare SCOLON declarVar
    (47) declarVar -> . empty
    (132) empty -> .

    VAR             shift and go to state 10
    VOID            reduce using rule 132 (empty -> .)
    INT             reduce using rule 132 (empty -> .)
    FLOAT           reduce using rule 132 (empty -> .)
    CHAR            reduce using rule 132 (empty -> .)
    MAIN            reduce using rule 132 (empty -> .)
    LBRACE          reduce using rule 132 (empty -> .)

    declarVar                      shift and go to state 50
    empty                          shift and go to state 11

state 42

    (13) listaIdDeclare -> idDeclare COMMA . listaIdDeclare
    (12) listaIdDeclare -> . idDeclare
    (13) listaIdDeclare -> . idDeclare COMMA listaIdDeclare
    (14) idDeclare -> . ID auxDeclare auxDeclare2
    (15) idDeclare -> . ID auxDeclare LBRACK CTE_I addCteTable RBRACK auxCTE
    (16) idDeclare -> . ID auxDeclare LBRACK CTE_I addCteTable COMMA CTE_I addCteTable auxCTE2 RBRACK

    ID              shift and go to state 36

    idDeclare                      shift and go to state 35
    listaIdDeclare                 shift and go to state 51

state 43

    (14) idDeclare -> ID auxDeclare . auxDeclare2
    (15) idDeclare -> ID auxDeclare . LBRACK CTE_I addCteTable RBRACK auxCTE
    (16) idDeclare -> ID auxDeclare . LBRACK CTE_I addCteTable COMMA CTE_I addCteTable auxCTE2 RBRACK
    (18) auxDeclare2 -> .

    LBRACK          shift and go to state 53
    COMMA           reduce using rule 18 (auxDeclare2 -> .)
    SCOLON          reduce using rule 18 (auxDeclare2 -> .)

    auxDeclare2                    shift and go to state 52

state 44

    (6) declarClases -> CLASS ID herencia LBRACE ATTRIBUTES declarAttributes . METHODS declarMethods RBRACE declarClases

    METHODS         shift and go to state 54


state 45

    (10) declarAttributes -> tipo . COLON listaIdDeclare SCOLON declarAttributes

    COLON           shift and go to state 55


state 46

    (11) declarAttributes -> empty .

    METHODS         reduce using rule 11 (declarAttributes -> empty .)


state 47

    (8) herencia -> LT EXTENDS ID GT .

    LBRACE          reduce using rule 8 (herencia -> LT EXTENDS ID GT .)


state 48

    (1) program -> PROGRAM ID initProg SCOLON declarClases declarVar addGlobSize definFunc MAIN auxMain LPAREN . RPAREN declarVar LBRACE listaEstatutos RBRACE endProg prueba

    RPAREN          shift and go to state 56


state 49

    (48) definFunc -> tipoMethod FUNC ID auxFuncion . LPAREN listaParam RPAREN declarVar setDI LBRACE listaEstatutos RBRACE endF definFunc

    LPAREN          shift and go to state 57


state 50

    (46) declarVar -> VAR tipo COLON listaIdDeclare SCOLON declarVar .

    VOID            reduce using rule 46 (declarVar -> VAR tipo COLON listaIdDeclare SCOLON declarVar .)
    INT             reduce using rule 46 (declarVar -> VAR tipo COLON listaIdDeclare SCOLON declarVar .)
    FLOAT           reduce using rule 46 (declarVar -> VAR tipo COLON listaIdDeclare SCOLON declarVar .)
    CHAR            reduce using rule 46 (declarVar -> VAR tipo COLON listaIdDeclare SCOLON declarVar .)
    MAIN            reduce using rule 46 (declarVar -> VAR tipo COLON listaIdDeclare SCOLON declarVar .)
    LBRACE          reduce using rule 46 (declarVar -> VAR tipo COLON listaIdDeclare SCOLON declarVar .)


state 51

    (13) listaIdDeclare -> idDeclare COMMA listaIdDeclare .

    SCOLON          reduce using rule 13 (listaIdDeclare -> idDeclare COMMA listaIdDeclare .)


state 52

    (14) idDeclare -> ID auxDeclare auxDeclare2 .

    COMMA           reduce using rule 14 (idDeclare -> ID auxDeclare auxDeclare2 .)
    SCOLON          reduce using rule 14 (idDeclare -> ID auxDeclare auxDeclare2 .)


state 53

    (15) idDeclare -> ID auxDeclare LBRACK . CTE_I addCteTable RBRACK auxCTE
    (16) idDeclare -> ID auxDeclare LBRACK . CTE_I addCteTable COMMA CTE_I addCteTable auxCTE2 RBRACK

    CTE_I           shift and go to state 58


state 54

    (6) declarClases -> CLASS ID herencia LBRACE ATTRIBUTES declarAttributes METHODS . declarMethods RBRACE declarClases
    (40) declarMethods -> . tipoMethod FUNC ID LPAREN listaParam RPAREN LBRACE listaEstatutos RBRACE declarMethods
    (41) declarMethods -> . empty
    (36) tipoMethod -> . VOID
    (37) tipoMethod -> . INT
    (38) tipoMethod -> . FLOAT
    (39) tipoMethod -> . CHAR
    (132) empty -> .

    VOID            shift and go to state 25
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    CHAR            shift and go to state 28
    RBRACE          reduce using rule 132 (empty -> .)

    declarMethods                  shift and go to state 59
    tipoMethod                     shift and go to state 60
    empty                          shift and go to state 61

state 55

    (10) declarAttributes -> tipo COLON . listaIdDeclare SCOLON declarAttributes
    (12) listaIdDeclare -> . idDeclare
    (13) listaIdDeclare -> . idDeclare COMMA listaIdDeclare
    (14) idDeclare -> . ID auxDeclare auxDeclare2
    (15) idDeclare -> . ID auxDeclare LBRACK CTE_I addCteTable RBRACK auxCTE
    (16) idDeclare -> . ID auxDeclare LBRACK CTE_I addCteTable COMMA CTE_I addCteTable auxCTE2 RBRACK

    ID              shift and go to state 36

    listaIdDeclare                 shift and go to state 62
    idDeclare                      shift and go to state 35

state 56

    (1) program -> PROGRAM ID initProg SCOLON declarClases declarVar addGlobSize definFunc MAIN auxMain LPAREN RPAREN . declarVar LBRACE listaEstatutos RBRACE endProg prueba
    (46) declarVar -> . VAR tipo COLON listaIdDeclare SCOLON declarVar
    (47) declarVar -> . empty
    (132) empty -> .

    VAR             shift and go to state 10
    LBRACE          reduce using rule 132 (empty -> .)

    declarVar                      shift and go to state 63
    empty                          shift and go to state 11

state 57

    (48) definFunc -> tipoMethod FUNC ID auxFuncion LPAREN . listaParam RPAREN declarVar setDI LBRACE listaEstatutos RBRACE endF definFunc
    (42) listaParam -> . param
    (43) listaParam -> . param COMMA listaParam
    (44) listaParam -> . empty
    (45) param -> . tipo COLON ID
    (132) empty -> .
    (32) tipo -> . ID
    (33) tipo -> . INT
    (34) tipo -> . FLOAT
    (35) tipo -> . CHAR

    RPAREN          reduce using rule 132 (empty -> .)
    ID              shift and go to state 15
    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    CHAR            shift and go to state 18

    listaParam                     shift and go to state 64
    param                          shift and go to state 65
    empty                          shift and go to state 66
    tipo                           shift and go to state 67

state 58

    (15) idDeclare -> ID auxDeclare LBRACK CTE_I . addCteTable RBRACK auxCTE
    (16) idDeclare -> ID auxDeclare LBRACK CTE_I . addCteTable COMMA CTE_I addCteTable auxCTE2 RBRACK
    (122) addCteTable -> .

    RBRACK          reduce using rule 122 (addCteTable -> .)
    COMMA           reduce using rule 122 (addCteTable -> .)

    addCteTable                    shift and go to state 68

state 59

    (6) declarClases -> CLASS ID herencia LBRACE ATTRIBUTES declarAttributes METHODS declarMethods . RBRACE declarClases

    RBRACE          shift and go to state 69


state 60

    (40) declarMethods -> tipoMethod . FUNC ID LPAREN listaParam RPAREN LBRACE listaEstatutos RBRACE declarMethods

    FUNC            shift and go to state 70


state 61

    (41) declarMethods -> empty .

    RBRACE          reduce using rule 41 (declarMethods -> empty .)


state 62

    (10) declarAttributes -> tipo COLON listaIdDeclare . SCOLON declarAttributes

    SCOLON          shift and go to state 71


state 63

    (1) program -> PROGRAM ID initProg SCOLON declarClases declarVar addGlobSize definFunc MAIN auxMain LPAREN RPAREN declarVar . LBRACE listaEstatutos RBRACE endProg prueba

    LBRACE          shift and go to state 72


state 64

    (48) definFunc -> tipoMethod FUNC ID auxFuncion LPAREN listaParam . RPAREN declarVar setDI LBRACE listaEstatutos RBRACE endF definFunc

    RPAREN          shift and go to state 73


state 65

    (42) listaParam -> param .
    (43) listaParam -> param . COMMA listaParam

    RPAREN          reduce using rule 42 (listaParam -> param .)
    COMMA           shift and go to state 74


state 66

    (44) listaParam -> empty .

    RPAREN          reduce using rule 44 (listaParam -> empty .)


state 67

    (45) param -> tipo . COLON ID

    COLON           shift and go to state 75


state 68

    (15) idDeclare -> ID auxDeclare LBRACK CTE_I addCteTable . RBRACK auxCTE
    (16) idDeclare -> ID auxDeclare LBRACK CTE_I addCteTable . COMMA CTE_I addCteTable auxCTE2 RBRACK

    RBRACK          shift and go to state 76
    COMMA           shift and go to state 77


state 69

    (6) declarClases -> CLASS ID herencia LBRACE ATTRIBUTES declarAttributes METHODS declarMethods RBRACE . declarClases
    (6) declarClases -> . CLASS ID herencia LBRACE ATTRIBUTES declarAttributes METHODS declarMethods RBRACE declarClases
    (7) declarClases -> . empty
    (132) empty -> .

    CLASS           shift and go to state 7
    VAR             reduce using rule 132 (empty -> .)
    VOID            reduce using rule 132 (empty -> .)
    INT             reduce using rule 132 (empty -> .)
    FLOAT           reduce using rule 132 (empty -> .)
    CHAR            reduce using rule 132 (empty -> .)
    MAIN            reduce using rule 132 (empty -> .)

    declarClases                   shift and go to state 78
    empty                          shift and go to state 8

state 70

    (40) declarMethods -> tipoMethod FUNC . ID LPAREN listaParam RPAREN LBRACE listaEstatutos RBRACE declarMethods

    ID              shift and go to state 79


state 71

    (10) declarAttributes -> tipo COLON listaIdDeclare SCOLON . declarAttributes
    (10) declarAttributes -> . tipo COLON listaIdDeclare SCOLON declarAttributes
    (11) declarAttributes -> . empty
    (32) tipo -> . ID
    (33) tipo -> . INT
    (34) tipo -> . FLOAT
    (35) tipo -> . CHAR
    (132) empty -> .

    ID              shift and go to state 15
    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    CHAR            shift and go to state 18
    METHODS         reduce using rule 132 (empty -> .)

    tipo                           shift and go to state 45
    declarAttributes               shift and go to state 80
    empty                          shift and go to state 46

state 72

    (1) program -> PROGRAM ID initProg SCOLON declarClases declarVar addGlobSize definFunc MAIN auxMain LPAREN RPAREN declarVar LBRACE . listaEstatutos RBRACE endProg prueba
    (53) listaEstatutos -> . estatutos listaEstatutos
    (54) listaEstatutos -> . empty
    (55) estatutos -> . llamada SCOLON
    (56) estatutos -> . asignacion SCOLON
    (57) estatutos -> . returnf SCOLON
    (58) estatutos -> . lectura SCOLON
    (59) estatutos -> . escritura SCOLON
    (60) estatutos -> . condicion
    (61) estatutos -> . cond_w
    (62) estatutos -> . cond_f
    (132) empty -> .
    (65) llamada -> . ID DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> . ID verExist LPAREN enviaParam coherenceGo RPAREN
    (63) asignacion -> . idCall ASIGNA pushPoper exp asignStep2
    (75) returnf -> . RETURN pushPoper LPAREN exp RPAREN popReturn
    (77) lectura -> . READ pushPoper LPAREN listaId RPAREN
    (82) escritura -> . WRITE pushPoper LPAREN exp popIO lextra RPAREN
    (83) escritura -> . WRITE pushPoper LPAREN LETRERO letreroPush popIO lextra RPAREN
    (89) condicion -> . IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE
    (90) condicion -> . IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE ELSE cond3 LBRACE listaEstatutos RBRACE
    (93) cond_w -> . WHILE step1While LPAREN exp RPAREN step2While DO LBRACE listaEstatutos RBRACE step3While
    (97) cond_f -> . FOR asignacion TO exp step1While step1For step2While DO LBRACE listaEstatutos RBRACE step3While
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    RBRACE          reduce using rule 132 (empty -> .)
    ID              shift and go to state 81
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    WHILE           shift and go to state 98
    FOR             shift and go to state 99

    listaEstatutos                 shift and go to state 82
    estatutos                      shift and go to state 83
    empty                          shift and go to state 84
    llamada                        shift and go to state 85
    asignacion                     shift and go to state 86
    returnf                        shift and go to state 87
    lectura                        shift and go to state 88
    escritura                      shift and go to state 89
    condicion                      shift and go to state 90
    cond_w                         shift and go to state 91
    cond_f                         shift and go to state 92
    idCall                         shift and go to state 93

state 73

    (48) definFunc -> tipoMethod FUNC ID auxFuncion LPAREN listaParam RPAREN . declarVar setDI LBRACE listaEstatutos RBRACE endF definFunc
    (46) declarVar -> . VAR tipo COLON listaIdDeclare SCOLON declarVar
    (47) declarVar -> . empty
    (132) empty -> .

    VAR             shift and go to state 10
    LBRACE          reduce using rule 132 (empty -> .)

    declarVar                      shift and go to state 100
    empty                          shift and go to state 11

state 74

    (43) listaParam -> param COMMA . listaParam
    (42) listaParam -> . param
    (43) listaParam -> . param COMMA listaParam
    (44) listaParam -> . empty
    (45) param -> . tipo COLON ID
    (132) empty -> .
    (32) tipo -> . ID
    (33) tipo -> . INT
    (34) tipo -> . FLOAT
    (35) tipo -> . CHAR

    RPAREN          reduce using rule 132 (empty -> .)
    ID              shift and go to state 15
    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    CHAR            shift and go to state 18

    param                          shift and go to state 65
    listaParam                     shift and go to state 101
    empty                          shift and go to state 66
    tipo                           shift and go to state 67

state 75

    (45) param -> tipo COLON . ID

    ID              shift and go to state 102


state 76

    (15) idDeclare -> ID auxDeclare LBRACK CTE_I addCteTable RBRACK . auxCTE
    (19) auxCTE -> .

    COMMA           reduce using rule 19 (auxCTE -> .)
    SCOLON          reduce using rule 19 (auxCTE -> .)

    auxCTE                         shift and go to state 103

state 77

    (16) idDeclare -> ID auxDeclare LBRACK CTE_I addCteTable COMMA . CTE_I addCteTable auxCTE2 RBRACK

    CTE_I           shift and go to state 104


state 78

    (6) declarClases -> CLASS ID herencia LBRACE ATTRIBUTES declarAttributes METHODS declarMethods RBRACE declarClases .

    VAR             reduce using rule 6 (declarClases -> CLASS ID herencia LBRACE ATTRIBUTES declarAttributes METHODS declarMethods RBRACE declarClases .)
    VOID            reduce using rule 6 (declarClases -> CLASS ID herencia LBRACE ATTRIBUTES declarAttributes METHODS declarMethods RBRACE declarClases .)
    INT             reduce using rule 6 (declarClases -> CLASS ID herencia LBRACE ATTRIBUTES declarAttributes METHODS declarMethods RBRACE declarClases .)
    FLOAT           reduce using rule 6 (declarClases -> CLASS ID herencia LBRACE ATTRIBUTES declarAttributes METHODS declarMethods RBRACE declarClases .)
    CHAR            reduce using rule 6 (declarClases -> CLASS ID herencia LBRACE ATTRIBUTES declarAttributes METHODS declarMethods RBRACE declarClases .)
    MAIN            reduce using rule 6 (declarClases -> CLASS ID herencia LBRACE ATTRIBUTES declarAttributes METHODS declarMethods RBRACE declarClases .)


state 79

    (40) declarMethods -> tipoMethod FUNC ID . LPAREN listaParam RPAREN LBRACE listaEstatutos RBRACE declarMethods

    LPAREN          shift and go to state 105


state 80

    (10) declarAttributes -> tipo COLON listaIdDeclare SCOLON declarAttributes .

    METHODS         reduce using rule 10 (declarAttributes -> tipo COLON listaIdDeclare SCOLON declarAttributes .)


state 81

    (65) llamada -> ID . DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> ID . verExist LPAREN enviaParam coherenceGo RPAREN
    (21) idCall -> ID . idCallaux checkDim
    (22) idCall -> ID . idCallaux DOT ID
    (23) idCall -> ID . idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> ID . idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2
    (71) verExist -> .
    (25) idCallaux -> .

  ! shift/reduce conflict for DOT resolved as shift
    DOT             shift and go to state 106
    LPAREN          reduce using rule 71 (verExist -> .)
    LBRACK          reduce using rule 25 (idCallaux -> .)
    ASIGNA          reduce using rule 25 (idCallaux -> .)
    MULT            reduce using rule 25 (idCallaux -> .)
    DIV             reduce using rule 25 (idCallaux -> .)
    PLUS            reduce using rule 25 (idCallaux -> .)
    MINUS           reduce using rule 25 (idCallaux -> .)
    LT              reduce using rule 25 (idCallaux -> .)
    GT              reduce using rule 25 (idCallaux -> .)
    LTE             reduce using rule 25 (idCallaux -> .)
    GTE             reduce using rule 25 (idCallaux -> .)
    EQUALS          reduce using rule 25 (idCallaux -> .)
    NEQUALS         reduce using rule 25 (idCallaux -> .)
    AND             reduce using rule 25 (idCallaux -> .)
    OR              reduce using rule 25 (idCallaux -> .)
    RPAREN          reduce using rule 25 (idCallaux -> .)
    COMMA           reduce using rule 25 (idCallaux -> .)
    SCOLON          reduce using rule 25 (idCallaux -> .)
    TO              reduce using rule 25 (idCallaux -> .)
    DO              reduce using rule 25 (idCallaux -> .)
    RBRACK          reduce using rule 25 (idCallaux -> .)

  ! DOT             [ reduce using rule 25 (idCallaux -> .) ]

    verExist                       shift and go to state 107
    idCallaux                      shift and go to state 108

state 82

    (1) program -> PROGRAM ID initProg SCOLON declarClases declarVar addGlobSize definFunc MAIN auxMain LPAREN RPAREN declarVar LBRACE listaEstatutos . RBRACE endProg prueba

    RBRACE          shift and go to state 109


state 83

    (53) listaEstatutos -> estatutos . listaEstatutos
    (53) listaEstatutos -> . estatutos listaEstatutos
    (54) listaEstatutos -> . empty
    (55) estatutos -> . llamada SCOLON
    (56) estatutos -> . asignacion SCOLON
    (57) estatutos -> . returnf SCOLON
    (58) estatutos -> . lectura SCOLON
    (59) estatutos -> . escritura SCOLON
    (60) estatutos -> . condicion
    (61) estatutos -> . cond_w
    (62) estatutos -> . cond_f
    (132) empty -> .
    (65) llamada -> . ID DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> . ID verExist LPAREN enviaParam coherenceGo RPAREN
    (63) asignacion -> . idCall ASIGNA pushPoper exp asignStep2
    (75) returnf -> . RETURN pushPoper LPAREN exp RPAREN popReturn
    (77) lectura -> . READ pushPoper LPAREN listaId RPAREN
    (82) escritura -> . WRITE pushPoper LPAREN exp popIO lextra RPAREN
    (83) escritura -> . WRITE pushPoper LPAREN LETRERO letreroPush popIO lextra RPAREN
    (89) condicion -> . IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE
    (90) condicion -> . IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE ELSE cond3 LBRACE listaEstatutos RBRACE
    (93) cond_w -> . WHILE step1While LPAREN exp RPAREN step2While DO LBRACE listaEstatutos RBRACE step3While
    (97) cond_f -> . FOR asignacion TO exp step1While step1For step2While DO LBRACE listaEstatutos RBRACE step3While
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    RBRACE          reduce using rule 132 (empty -> .)
    ID              shift and go to state 81
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    WHILE           shift and go to state 98
    FOR             shift and go to state 99

    estatutos                      shift and go to state 83
    listaEstatutos                 shift and go to state 110
    empty                          shift and go to state 84
    llamada                        shift and go to state 85
    asignacion                     shift and go to state 86
    returnf                        shift and go to state 87
    lectura                        shift and go to state 88
    escritura                      shift and go to state 89
    condicion                      shift and go to state 90
    cond_w                         shift and go to state 91
    cond_f                         shift and go to state 92
    idCall                         shift and go to state 93

state 84

    (54) listaEstatutos -> empty .

    RBRACE          reduce using rule 54 (listaEstatutos -> empty .)


state 85

    (55) estatutos -> llamada . SCOLON

    SCOLON          shift and go to state 111


state 86

    (56) estatutos -> asignacion . SCOLON

    SCOLON          shift and go to state 112


state 87

    (57) estatutos -> returnf . SCOLON

    SCOLON          shift and go to state 113


state 88

    (58) estatutos -> lectura . SCOLON

    SCOLON          shift and go to state 114


state 89

    (59) estatutos -> escritura . SCOLON

    SCOLON          shift and go to state 115


state 90

    (60) estatutos -> condicion .

    ID              reduce using rule 60 (estatutos -> condicion .)
    RETURN          reduce using rule 60 (estatutos -> condicion .)
    READ            reduce using rule 60 (estatutos -> condicion .)
    WRITE           reduce using rule 60 (estatutos -> condicion .)
    IF              reduce using rule 60 (estatutos -> condicion .)
    WHILE           reduce using rule 60 (estatutos -> condicion .)
    FOR             reduce using rule 60 (estatutos -> condicion .)
    RBRACE          reduce using rule 60 (estatutos -> condicion .)


state 91

    (61) estatutos -> cond_w .

    ID              reduce using rule 61 (estatutos -> cond_w .)
    RETURN          reduce using rule 61 (estatutos -> cond_w .)
    READ            reduce using rule 61 (estatutos -> cond_w .)
    WRITE           reduce using rule 61 (estatutos -> cond_w .)
    IF              reduce using rule 61 (estatutos -> cond_w .)
    WHILE           reduce using rule 61 (estatutos -> cond_w .)
    FOR             reduce using rule 61 (estatutos -> cond_w .)
    RBRACE          reduce using rule 61 (estatutos -> cond_w .)


state 92

    (62) estatutos -> cond_f .

    ID              reduce using rule 62 (estatutos -> cond_f .)
    RETURN          reduce using rule 62 (estatutos -> cond_f .)
    READ            reduce using rule 62 (estatutos -> cond_f .)
    WRITE           reduce using rule 62 (estatutos -> cond_f .)
    IF              reduce using rule 62 (estatutos -> cond_f .)
    WHILE           reduce using rule 62 (estatutos -> cond_f .)
    FOR             reduce using rule 62 (estatutos -> cond_f .)
    RBRACE          reduce using rule 62 (estatutos -> cond_f .)


state 93

    (63) asignacion -> idCall . ASIGNA pushPoper exp asignStep2

    ASIGNA          shift and go to state 116


state 94

    (75) returnf -> RETURN . pushPoper LPAREN exp RPAREN popReturn
    (131) pushPoper -> .

    LPAREN          reduce using rule 131 (pushPoper -> .)

    pushPoper                      shift and go to state 117

state 95

    (77) lectura -> READ . pushPoper LPAREN listaId RPAREN
    (131) pushPoper -> .

    LPAREN          reduce using rule 131 (pushPoper -> .)

    pushPoper                      shift and go to state 118

state 96

    (82) escritura -> WRITE . pushPoper LPAREN exp popIO lextra RPAREN
    (83) escritura -> WRITE . pushPoper LPAREN LETRERO letreroPush popIO lextra RPAREN
    (131) pushPoper -> .

    LPAREN          reduce using rule 131 (pushPoper -> .)

    pushPoper                      shift and go to state 119

state 97

    (89) condicion -> IF . LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE
    (90) condicion -> IF . LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE ELSE cond3 LBRACE listaEstatutos RBRACE

    LPAREN          shift and go to state 120


state 98

    (93) cond_w -> WHILE . step1While LPAREN exp RPAREN step2While DO LBRACE listaEstatutos RBRACE step3While
    (94) step1While -> .

    LPAREN          reduce using rule 94 (step1While -> .)

    step1While                     shift and go to state 121

state 99

    (97) cond_f -> FOR . asignacion TO exp step1While step1For step2While DO LBRACE listaEstatutos RBRACE step3While
    (63) asignacion -> . idCall ASIGNA pushPoper exp asignStep2
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    ID              shift and go to state 123

    asignacion                     shift and go to state 122
    idCall                         shift and go to state 93

state 100

    (48) definFunc -> tipoMethod FUNC ID auxFuncion LPAREN listaParam RPAREN declarVar . setDI LBRACE listaEstatutos RBRACE endF definFunc
    (51) setDI -> .

    LBRACE          reduce using rule 51 (setDI -> .)

    setDI                          shift and go to state 124

state 101

    (43) listaParam -> param COMMA listaParam .

    RPAREN          reduce using rule 43 (listaParam -> param COMMA listaParam .)


state 102

    (45) param -> tipo COLON ID .

    COMMA           reduce using rule 45 (param -> tipo COLON ID .)
    RPAREN          reduce using rule 45 (param -> tipo COLON ID .)


state 103

    (15) idDeclare -> ID auxDeclare LBRACK CTE_I addCteTable RBRACK auxCTE .

    COMMA           reduce using rule 15 (idDeclare -> ID auxDeclare LBRACK CTE_I addCteTable RBRACK auxCTE .)
    SCOLON          reduce using rule 15 (idDeclare -> ID auxDeclare LBRACK CTE_I addCteTable RBRACK auxCTE .)


state 104

    (16) idDeclare -> ID auxDeclare LBRACK CTE_I addCteTable COMMA CTE_I . addCteTable auxCTE2 RBRACK
    (122) addCteTable -> .

    RBRACK          reduce using rule 122 (addCteTable -> .)

    addCteTable                    shift and go to state 125

state 105

    (40) declarMethods -> tipoMethod FUNC ID LPAREN . listaParam RPAREN LBRACE listaEstatutos RBRACE declarMethods
    (42) listaParam -> . param
    (43) listaParam -> . param COMMA listaParam
    (44) listaParam -> . empty
    (45) param -> . tipo COLON ID
    (132) empty -> .
    (32) tipo -> . ID
    (33) tipo -> . INT
    (34) tipo -> . FLOAT
    (35) tipo -> . CHAR

    RPAREN          reduce using rule 132 (empty -> .)
    ID              shift and go to state 15
    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    CHAR            shift and go to state 18

    listaParam                     shift and go to state 126
    param                          shift and go to state 65
    empty                          shift and go to state 66
    tipo                           shift and go to state 67

state 106

    (65) llamada -> ID DOT . ID LPAREN enviaParam RPAREN

    ID              shift and go to state 127


state 107

    (66) llamada -> ID verExist . LPAREN enviaParam coherenceGo RPAREN

    LPAREN          shift and go to state 128


state 108

    (21) idCall -> ID idCallaux . checkDim
    (22) idCall -> ID idCallaux . DOT ID
    (23) idCall -> ID idCallaux . LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> ID idCallaux . LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2
    (29) checkDim -> .

    DOT             shift and go to state 130
    LBRACK          shift and go to state 131
    ASIGNA          reduce using rule 29 (checkDim -> .)
    MULT            reduce using rule 29 (checkDim -> .)
    DIV             reduce using rule 29 (checkDim -> .)
    PLUS            reduce using rule 29 (checkDim -> .)
    MINUS           reduce using rule 29 (checkDim -> .)
    LT              reduce using rule 29 (checkDim -> .)
    GT              reduce using rule 29 (checkDim -> .)
    LTE             reduce using rule 29 (checkDim -> .)
    GTE             reduce using rule 29 (checkDim -> .)
    EQUALS          reduce using rule 29 (checkDim -> .)
    NEQUALS         reduce using rule 29 (checkDim -> .)
    AND             reduce using rule 29 (checkDim -> .)
    OR              reduce using rule 29 (checkDim -> .)
    RPAREN          reduce using rule 29 (checkDim -> .)
    COMMA           reduce using rule 29 (checkDim -> .)
    SCOLON          reduce using rule 29 (checkDim -> .)
    TO              reduce using rule 29 (checkDim -> .)
    DO              reduce using rule 29 (checkDim -> .)
    RBRACK          reduce using rule 29 (checkDim -> .)

    checkDim                       shift and go to state 129

state 109

    (1) program -> PROGRAM ID initProg SCOLON declarClases declarVar addGlobSize definFunc MAIN auxMain LPAREN RPAREN declarVar LBRACE listaEstatutos RBRACE . endProg prueba
    (5) endProg -> .

    $end            reduce using rule 5 (endProg -> .)

    endProg                        shift and go to state 132

state 110

    (53) listaEstatutos -> estatutos listaEstatutos .

    RBRACE          reduce using rule 53 (listaEstatutos -> estatutos listaEstatutos .)


state 111

    (55) estatutos -> llamada SCOLON .

    ID              reduce using rule 55 (estatutos -> llamada SCOLON .)
    RETURN          reduce using rule 55 (estatutos -> llamada SCOLON .)
    READ            reduce using rule 55 (estatutos -> llamada SCOLON .)
    WRITE           reduce using rule 55 (estatutos -> llamada SCOLON .)
    IF              reduce using rule 55 (estatutos -> llamada SCOLON .)
    WHILE           reduce using rule 55 (estatutos -> llamada SCOLON .)
    FOR             reduce using rule 55 (estatutos -> llamada SCOLON .)
    RBRACE          reduce using rule 55 (estatutos -> llamada SCOLON .)


state 112

    (56) estatutos -> asignacion SCOLON .

    ID              reduce using rule 56 (estatutos -> asignacion SCOLON .)
    RETURN          reduce using rule 56 (estatutos -> asignacion SCOLON .)
    READ            reduce using rule 56 (estatutos -> asignacion SCOLON .)
    WRITE           reduce using rule 56 (estatutos -> asignacion SCOLON .)
    IF              reduce using rule 56 (estatutos -> asignacion SCOLON .)
    WHILE           reduce using rule 56 (estatutos -> asignacion SCOLON .)
    FOR             reduce using rule 56 (estatutos -> asignacion SCOLON .)
    RBRACE          reduce using rule 56 (estatutos -> asignacion SCOLON .)


state 113

    (57) estatutos -> returnf SCOLON .

    ID              reduce using rule 57 (estatutos -> returnf SCOLON .)
    RETURN          reduce using rule 57 (estatutos -> returnf SCOLON .)
    READ            reduce using rule 57 (estatutos -> returnf SCOLON .)
    WRITE           reduce using rule 57 (estatutos -> returnf SCOLON .)
    IF              reduce using rule 57 (estatutos -> returnf SCOLON .)
    WHILE           reduce using rule 57 (estatutos -> returnf SCOLON .)
    FOR             reduce using rule 57 (estatutos -> returnf SCOLON .)
    RBRACE          reduce using rule 57 (estatutos -> returnf SCOLON .)


state 114

    (58) estatutos -> lectura SCOLON .

    ID              reduce using rule 58 (estatutos -> lectura SCOLON .)
    RETURN          reduce using rule 58 (estatutos -> lectura SCOLON .)
    READ            reduce using rule 58 (estatutos -> lectura SCOLON .)
    WRITE           reduce using rule 58 (estatutos -> lectura SCOLON .)
    IF              reduce using rule 58 (estatutos -> lectura SCOLON .)
    WHILE           reduce using rule 58 (estatutos -> lectura SCOLON .)
    FOR             reduce using rule 58 (estatutos -> lectura SCOLON .)
    RBRACE          reduce using rule 58 (estatutos -> lectura SCOLON .)


state 115

    (59) estatutos -> escritura SCOLON .

    ID              reduce using rule 59 (estatutos -> escritura SCOLON .)
    RETURN          reduce using rule 59 (estatutos -> escritura SCOLON .)
    READ            reduce using rule 59 (estatutos -> escritura SCOLON .)
    WRITE           reduce using rule 59 (estatutos -> escritura SCOLON .)
    IF              reduce using rule 59 (estatutos -> escritura SCOLON .)
    WHILE           reduce using rule 59 (estatutos -> escritura SCOLON .)
    FOR             reduce using rule 59 (estatutos -> escritura SCOLON .)
    RBRACE          reduce using rule 59 (estatutos -> escritura SCOLON .)


state 116

    (63) asignacion -> idCall ASIGNA . pushPoper exp asignStep2
    (131) pushPoper -> .

    LPAREN          reduce using rule 131 (pushPoper -> .)
    CTE_I           reduce using rule 131 (pushPoper -> .)
    CTE_F           reduce using rule 131 (pushPoper -> .)
    CTE_C           reduce using rule 131 (pushPoper -> .)
    ID              reduce using rule 131 (pushPoper -> .)

    pushPoper                      shift and go to state 133

state 117

    (75) returnf -> RETURN pushPoper . LPAREN exp RPAREN popReturn

    LPAREN          shift and go to state 134


state 118

    (77) lectura -> READ pushPoper . LPAREN listaId RPAREN

    LPAREN          shift and go to state 135


state 119

    (82) escritura -> WRITE pushPoper . LPAREN exp popIO lextra RPAREN
    (83) escritura -> WRITE pushPoper . LPAREN LETRERO letreroPush popIO lextra RPAREN

    LPAREN          shift and go to state 136


state 120

    (89) condicion -> IF LPAREN . exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE
    (90) condicion -> IF LPAREN . exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE ELSE cond3 LBRACE listaEstatutos RBRACE
    (99) exp -> . texp step7
    (100) exp -> . texp step7 OR pushPoper exp
    (101) texp -> . gexp step6
    (102) texp -> . gexp step6 AND pushPoper texp
    (103) gexp -> . mexp step5
    (104) gexp -> . mexp step5 LT pushPoper gexp
    (105) gexp -> . mexp step5 GT pushPoper gexp
    (106) gexp -> . mexp step5 LTE pushPoper gexp
    (107) gexp -> . mexp step5 GTE pushPoper gexp
    (108) gexp -> . mexp step5 EQUALS pushPoper gexp
    (109) gexp -> . mexp step5 NEQUALS pushPoper gexp
    (110) mexp -> . t step4
    (111) mexp -> . t step4 PLUS pushPoper mexp
    (112) mexp -> . t step4 MINUS pushPoper mexp
    (113) t -> . f step3
    (114) t -> . f step3 MULT pushPoper t
    (115) t -> . f step3 DIV pushPoper t
    (116) f -> . LPAREN addFF exp RPAREN rmFF
    (117) f -> . CTE_I addCteTable step1
    (118) f -> . CTE_F addCteTable step1
    (119) f -> . CTE_C addCteTable step1
    (120) f -> . llamada
    (121) f -> . idCall
    (65) llamada -> . ID DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> . ID verExist LPAREN enviaParam coherenceGo RPAREN
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    LPAREN          shift and go to state 137
    CTE_I           shift and go to state 144
    CTE_F           shift and go to state 145
    CTE_C           shift and go to state 146
    ID              shift and go to state 81

    exp                            shift and go to state 138
    texp                           shift and go to state 139
    gexp                           shift and go to state 140
    mexp                           shift and go to state 141
    t                              shift and go to state 142
    f                              shift and go to state 143
    llamada                        shift and go to state 147
    idCall                         shift and go to state 148

state 121

    (93) cond_w -> WHILE step1While . LPAREN exp RPAREN step2While DO LBRACE listaEstatutos RBRACE step3While

    LPAREN          shift and go to state 149


state 122

    (97) cond_f -> FOR asignacion . TO exp step1While step1For step2While DO LBRACE listaEstatutos RBRACE step3While

    TO              shift and go to state 150


state 123

    (21) idCall -> ID . idCallaux checkDim
    (22) idCall -> ID . idCallaux DOT ID
    (23) idCall -> ID . idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> ID . idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2
    (25) idCallaux -> .

    DOT             reduce using rule 25 (idCallaux -> .)
    LBRACK          reduce using rule 25 (idCallaux -> .)
    ASIGNA          reduce using rule 25 (idCallaux -> .)
    COMMA           reduce using rule 25 (idCallaux -> .)
    RPAREN          reduce using rule 25 (idCallaux -> .)

    idCallaux                      shift and go to state 108

state 124

    (48) definFunc -> tipoMethod FUNC ID auxFuncion LPAREN listaParam RPAREN declarVar setDI . LBRACE listaEstatutos RBRACE endF definFunc

    LBRACE          shift and go to state 151


state 125

    (16) idDeclare -> ID auxDeclare LBRACK CTE_I addCteTable COMMA CTE_I addCteTable . auxCTE2 RBRACK
    (20) auxCTE2 -> .

    RBRACK          reduce using rule 20 (auxCTE2 -> .)

    auxCTE2                        shift and go to state 152

state 126

    (40) declarMethods -> tipoMethod FUNC ID LPAREN listaParam . RPAREN LBRACE listaEstatutos RBRACE declarMethods

    RPAREN          shift and go to state 153


state 127

    (65) llamada -> ID DOT ID . LPAREN enviaParam RPAREN

    LPAREN          shift and go to state 154


state 128

    (66) llamada -> ID verExist LPAREN . enviaParam coherenceGo RPAREN
    (67) enviaParam -> . paramReferencia
    (68) enviaParam -> . empty
    (69) paramReferencia -> . exp paramType
    (70) paramReferencia -> . exp paramType COMMA paramCount paramReferencia
    (132) empty -> .
    (99) exp -> . texp step7
    (100) exp -> . texp step7 OR pushPoper exp
    (101) texp -> . gexp step6
    (102) texp -> . gexp step6 AND pushPoper texp
    (103) gexp -> . mexp step5
    (104) gexp -> . mexp step5 LT pushPoper gexp
    (105) gexp -> . mexp step5 GT pushPoper gexp
    (106) gexp -> . mexp step5 LTE pushPoper gexp
    (107) gexp -> . mexp step5 GTE pushPoper gexp
    (108) gexp -> . mexp step5 EQUALS pushPoper gexp
    (109) gexp -> . mexp step5 NEQUALS pushPoper gexp
    (110) mexp -> . t step4
    (111) mexp -> . t step4 PLUS pushPoper mexp
    (112) mexp -> . t step4 MINUS pushPoper mexp
    (113) t -> . f step3
    (114) t -> . f step3 MULT pushPoper t
    (115) t -> . f step3 DIV pushPoper t
    (116) f -> . LPAREN addFF exp RPAREN rmFF
    (117) f -> . CTE_I addCteTable step1
    (118) f -> . CTE_F addCteTable step1
    (119) f -> . CTE_C addCteTable step1
    (120) f -> . llamada
    (121) f -> . idCall
    (65) llamada -> . ID DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> . ID verExist LPAREN enviaParam coherenceGo RPAREN
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    RPAREN          reduce using rule 132 (empty -> .)
    LPAREN          shift and go to state 137
    CTE_I           shift and go to state 144
    CTE_F           shift and go to state 145
    CTE_C           shift and go to state 146
    ID              shift and go to state 81

    enviaParam                     shift and go to state 155
    paramReferencia                shift and go to state 156
    empty                          shift and go to state 157
    exp                            shift and go to state 158
    texp                           shift and go to state 139
    gexp                           shift and go to state 140
    mexp                           shift and go to state 141
    t                              shift and go to state 142
    f                              shift and go to state 143
    llamada                        shift and go to state 147
    idCall                         shift and go to state 148

state 129

    (21) idCall -> ID idCallaux checkDim .

    ASIGNA          reduce using rule 21 (idCall -> ID idCallaux checkDim .)
    MULT            reduce using rule 21 (idCall -> ID idCallaux checkDim .)
    DIV             reduce using rule 21 (idCall -> ID idCallaux checkDim .)
    PLUS            reduce using rule 21 (idCall -> ID idCallaux checkDim .)
    MINUS           reduce using rule 21 (idCall -> ID idCallaux checkDim .)
    LT              reduce using rule 21 (idCall -> ID idCallaux checkDim .)
    GT              reduce using rule 21 (idCall -> ID idCallaux checkDim .)
    LTE             reduce using rule 21 (idCall -> ID idCallaux checkDim .)
    GTE             reduce using rule 21 (idCall -> ID idCallaux checkDim .)
    EQUALS          reduce using rule 21 (idCall -> ID idCallaux checkDim .)
    NEQUALS         reduce using rule 21 (idCall -> ID idCallaux checkDim .)
    AND             reduce using rule 21 (idCall -> ID idCallaux checkDim .)
    OR              reduce using rule 21 (idCall -> ID idCallaux checkDim .)
    RPAREN          reduce using rule 21 (idCall -> ID idCallaux checkDim .)
    COMMA           reduce using rule 21 (idCall -> ID idCallaux checkDim .)
    SCOLON          reduce using rule 21 (idCall -> ID idCallaux checkDim .)
    TO              reduce using rule 21 (idCall -> ID idCallaux checkDim .)
    DO              reduce using rule 21 (idCall -> ID idCallaux checkDim .)
    RBRACK          reduce using rule 21 (idCall -> ID idCallaux checkDim .)


state 130

    (22) idCall -> ID idCallaux DOT . ID

    ID              shift and go to state 159


state 131

    (23) idCall -> ID idCallaux LBRACK . addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> ID idCallaux LBRACK . addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2
    (129) addFF -> .

    LPAREN          reduce using rule 129 (addFF -> .)
    CTE_I           reduce using rule 129 (addFF -> .)
    CTE_F           reduce using rule 129 (addFF -> .)
    CTE_C           reduce using rule 129 (addFF -> .)
    ID              reduce using rule 129 (addFF -> .)

    addFF                          shift and go to state 160

state 132

    (1) program -> PROGRAM ID initProg SCOLON declarClases declarVar addGlobSize definFunc MAIN auxMain LPAREN RPAREN declarVar LBRACE listaEstatutos RBRACE endProg . prueba
    (133) prueba -> .

    $end            reduce using rule 133 (prueba -> .)

    prueba                         shift and go to state 161

state 133

    (63) asignacion -> idCall ASIGNA pushPoper . exp asignStep2
    (99) exp -> . texp step7
    (100) exp -> . texp step7 OR pushPoper exp
    (101) texp -> . gexp step6
    (102) texp -> . gexp step6 AND pushPoper texp
    (103) gexp -> . mexp step5
    (104) gexp -> . mexp step5 LT pushPoper gexp
    (105) gexp -> . mexp step5 GT pushPoper gexp
    (106) gexp -> . mexp step5 LTE pushPoper gexp
    (107) gexp -> . mexp step5 GTE pushPoper gexp
    (108) gexp -> . mexp step5 EQUALS pushPoper gexp
    (109) gexp -> . mexp step5 NEQUALS pushPoper gexp
    (110) mexp -> . t step4
    (111) mexp -> . t step4 PLUS pushPoper mexp
    (112) mexp -> . t step4 MINUS pushPoper mexp
    (113) t -> . f step3
    (114) t -> . f step3 MULT pushPoper t
    (115) t -> . f step3 DIV pushPoper t
    (116) f -> . LPAREN addFF exp RPAREN rmFF
    (117) f -> . CTE_I addCteTable step1
    (118) f -> . CTE_F addCteTable step1
    (119) f -> . CTE_C addCteTable step1
    (120) f -> . llamada
    (121) f -> . idCall
    (65) llamada -> . ID DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> . ID verExist LPAREN enviaParam coherenceGo RPAREN
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    LPAREN          shift and go to state 137
    CTE_I           shift and go to state 144
    CTE_F           shift and go to state 145
    CTE_C           shift and go to state 146
    ID              shift and go to state 81

    idCall                         shift and go to state 148
    exp                            shift and go to state 162
    texp                           shift and go to state 139
    gexp                           shift and go to state 140
    mexp                           shift and go to state 141
    t                              shift and go to state 142
    f                              shift and go to state 143
    llamada                        shift and go to state 147

state 134

    (75) returnf -> RETURN pushPoper LPAREN . exp RPAREN popReturn
    (99) exp -> . texp step7
    (100) exp -> . texp step7 OR pushPoper exp
    (101) texp -> . gexp step6
    (102) texp -> . gexp step6 AND pushPoper texp
    (103) gexp -> . mexp step5
    (104) gexp -> . mexp step5 LT pushPoper gexp
    (105) gexp -> . mexp step5 GT pushPoper gexp
    (106) gexp -> . mexp step5 LTE pushPoper gexp
    (107) gexp -> . mexp step5 GTE pushPoper gexp
    (108) gexp -> . mexp step5 EQUALS pushPoper gexp
    (109) gexp -> . mexp step5 NEQUALS pushPoper gexp
    (110) mexp -> . t step4
    (111) mexp -> . t step4 PLUS pushPoper mexp
    (112) mexp -> . t step4 MINUS pushPoper mexp
    (113) t -> . f step3
    (114) t -> . f step3 MULT pushPoper t
    (115) t -> . f step3 DIV pushPoper t
    (116) f -> . LPAREN addFF exp RPAREN rmFF
    (117) f -> . CTE_I addCteTable step1
    (118) f -> . CTE_F addCteTable step1
    (119) f -> . CTE_C addCteTable step1
    (120) f -> . llamada
    (121) f -> . idCall
    (65) llamada -> . ID DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> . ID verExist LPAREN enviaParam coherenceGo RPAREN
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    LPAREN          shift and go to state 137
    CTE_I           shift and go to state 144
    CTE_F           shift and go to state 145
    CTE_C           shift and go to state 146
    ID              shift and go to state 81

    exp                            shift and go to state 163
    texp                           shift and go to state 139
    gexp                           shift and go to state 140
    mexp                           shift and go to state 141
    t                              shift and go to state 142
    f                              shift and go to state 143
    llamada                        shift and go to state 147
    idCall                         shift and go to state 148

state 135

    (77) lectura -> READ pushPoper LPAREN . listaId RPAREN
    (78) listaId -> . idCall popIO
    (79) listaId -> . idCall COMMA popIO insertOpRead listaId
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    ID              shift and go to state 123

    listaId                        shift and go to state 164
    idCall                         shift and go to state 165

state 136

    (82) escritura -> WRITE pushPoper LPAREN . exp popIO lextra RPAREN
    (83) escritura -> WRITE pushPoper LPAREN . LETRERO letreroPush popIO lextra RPAREN
    (99) exp -> . texp step7
    (100) exp -> . texp step7 OR pushPoper exp
    (101) texp -> . gexp step6
    (102) texp -> . gexp step6 AND pushPoper texp
    (103) gexp -> . mexp step5
    (104) gexp -> . mexp step5 LT pushPoper gexp
    (105) gexp -> . mexp step5 GT pushPoper gexp
    (106) gexp -> . mexp step5 LTE pushPoper gexp
    (107) gexp -> . mexp step5 GTE pushPoper gexp
    (108) gexp -> . mexp step5 EQUALS pushPoper gexp
    (109) gexp -> . mexp step5 NEQUALS pushPoper gexp
    (110) mexp -> . t step4
    (111) mexp -> . t step4 PLUS pushPoper mexp
    (112) mexp -> . t step4 MINUS pushPoper mexp
    (113) t -> . f step3
    (114) t -> . f step3 MULT pushPoper t
    (115) t -> . f step3 DIV pushPoper t
    (116) f -> . LPAREN addFF exp RPAREN rmFF
    (117) f -> . CTE_I addCteTable step1
    (118) f -> . CTE_F addCteTable step1
    (119) f -> . CTE_C addCteTable step1
    (120) f -> . llamada
    (121) f -> . idCall
    (65) llamada -> . ID DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> . ID verExist LPAREN enviaParam coherenceGo RPAREN
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    LETRERO         shift and go to state 167
    LPAREN          shift and go to state 137
    CTE_I           shift and go to state 144
    CTE_F           shift and go to state 145
    CTE_C           shift and go to state 146
    ID              shift and go to state 81

    exp                            shift and go to state 166
    texp                           shift and go to state 139
    gexp                           shift and go to state 140
    mexp                           shift and go to state 141
    t                              shift and go to state 142
    f                              shift and go to state 143
    llamada                        shift and go to state 147
    idCall                         shift and go to state 148

state 137

    (116) f -> LPAREN . addFF exp RPAREN rmFF
    (129) addFF -> .

    LPAREN          reduce using rule 129 (addFF -> .)
    CTE_I           reduce using rule 129 (addFF -> .)
    CTE_F           reduce using rule 129 (addFF -> .)
    CTE_C           reduce using rule 129 (addFF -> .)
    ID              reduce using rule 129 (addFF -> .)

    addFF                          shift and go to state 168

state 138

    (89) condicion -> IF LPAREN exp . RPAREN cond1 THEN LBRACE listaEstatutos RBRACE
    (90) condicion -> IF LPAREN exp . RPAREN cond1 THEN LBRACE listaEstatutos RBRACE ELSE cond3 LBRACE listaEstatutos RBRACE

    RPAREN          shift and go to state 169


state 139

    (99) exp -> texp . step7
    (100) exp -> texp . step7 OR pushPoper exp
    (128) step7 -> .

    OR              reduce using rule 128 (step7 -> .)
    RPAREN          reduce using rule 128 (step7 -> .)
    COMMA           reduce using rule 128 (step7 -> .)
    SCOLON          reduce using rule 128 (step7 -> .)
    TO              reduce using rule 128 (step7 -> .)
    DO              reduce using rule 128 (step7 -> .)
    RBRACK          reduce using rule 128 (step7 -> .)

    step7                          shift and go to state 170

state 140

    (101) texp -> gexp . step6
    (102) texp -> gexp . step6 AND pushPoper texp
    (127) step6 -> .

    AND             reduce using rule 127 (step6 -> .)
    OR              reduce using rule 127 (step6 -> .)
    RPAREN          reduce using rule 127 (step6 -> .)
    COMMA           reduce using rule 127 (step6 -> .)
    SCOLON          reduce using rule 127 (step6 -> .)
    TO              reduce using rule 127 (step6 -> .)
    DO              reduce using rule 127 (step6 -> .)
    RBRACK          reduce using rule 127 (step6 -> .)

    step6                          shift and go to state 171

state 141

    (103) gexp -> mexp . step5
    (104) gexp -> mexp . step5 LT pushPoper gexp
    (105) gexp -> mexp . step5 GT pushPoper gexp
    (106) gexp -> mexp . step5 LTE pushPoper gexp
    (107) gexp -> mexp . step5 GTE pushPoper gexp
    (108) gexp -> mexp . step5 EQUALS pushPoper gexp
    (109) gexp -> mexp . step5 NEQUALS pushPoper gexp
    (126) step5 -> .

    LT              reduce using rule 126 (step5 -> .)
    GT              reduce using rule 126 (step5 -> .)
    LTE             reduce using rule 126 (step5 -> .)
    GTE             reduce using rule 126 (step5 -> .)
    EQUALS          reduce using rule 126 (step5 -> .)
    NEQUALS         reduce using rule 126 (step5 -> .)
    AND             reduce using rule 126 (step5 -> .)
    OR              reduce using rule 126 (step5 -> .)
    RPAREN          reduce using rule 126 (step5 -> .)
    COMMA           reduce using rule 126 (step5 -> .)
    SCOLON          reduce using rule 126 (step5 -> .)
    TO              reduce using rule 126 (step5 -> .)
    DO              reduce using rule 126 (step5 -> .)
    RBRACK          reduce using rule 126 (step5 -> .)

    step5                          shift and go to state 172

state 142

    (110) mexp -> t . step4
    (111) mexp -> t . step4 PLUS pushPoper mexp
    (112) mexp -> t . step4 MINUS pushPoper mexp
    (125) step4 -> .

    PLUS            reduce using rule 125 (step4 -> .)
    MINUS           reduce using rule 125 (step4 -> .)
    LT              reduce using rule 125 (step4 -> .)
    GT              reduce using rule 125 (step4 -> .)
    LTE             reduce using rule 125 (step4 -> .)
    GTE             reduce using rule 125 (step4 -> .)
    EQUALS          reduce using rule 125 (step4 -> .)
    NEQUALS         reduce using rule 125 (step4 -> .)
    AND             reduce using rule 125 (step4 -> .)
    OR              reduce using rule 125 (step4 -> .)
    RPAREN          reduce using rule 125 (step4 -> .)
    COMMA           reduce using rule 125 (step4 -> .)
    SCOLON          reduce using rule 125 (step4 -> .)
    TO              reduce using rule 125 (step4 -> .)
    DO              reduce using rule 125 (step4 -> .)
    RBRACK          reduce using rule 125 (step4 -> .)

    step4                          shift and go to state 173

state 143

    (113) t -> f . step3
    (114) t -> f . step3 MULT pushPoper t
    (115) t -> f . step3 DIV pushPoper t
    (124) step3 -> .

    MULT            reduce using rule 124 (step3 -> .)
    DIV             reduce using rule 124 (step3 -> .)
    PLUS            reduce using rule 124 (step3 -> .)
    MINUS           reduce using rule 124 (step3 -> .)
    LT              reduce using rule 124 (step3 -> .)
    GT              reduce using rule 124 (step3 -> .)
    LTE             reduce using rule 124 (step3 -> .)
    GTE             reduce using rule 124 (step3 -> .)
    EQUALS          reduce using rule 124 (step3 -> .)
    NEQUALS         reduce using rule 124 (step3 -> .)
    AND             reduce using rule 124 (step3 -> .)
    OR              reduce using rule 124 (step3 -> .)
    RPAREN          reduce using rule 124 (step3 -> .)
    COMMA           reduce using rule 124 (step3 -> .)
    SCOLON          reduce using rule 124 (step3 -> .)
    TO              reduce using rule 124 (step3 -> .)
    DO              reduce using rule 124 (step3 -> .)
    RBRACK          reduce using rule 124 (step3 -> .)

    step3                          shift and go to state 174

state 144

    (117) f -> CTE_I . addCteTable step1
    (122) addCteTable -> .

    MULT            reduce using rule 122 (addCteTable -> .)
    DIV             reduce using rule 122 (addCteTable -> .)
    PLUS            reduce using rule 122 (addCteTable -> .)
    MINUS           reduce using rule 122 (addCteTable -> .)
    LT              reduce using rule 122 (addCteTable -> .)
    GT              reduce using rule 122 (addCteTable -> .)
    LTE             reduce using rule 122 (addCteTable -> .)
    GTE             reduce using rule 122 (addCteTable -> .)
    EQUALS          reduce using rule 122 (addCteTable -> .)
    NEQUALS         reduce using rule 122 (addCteTable -> .)
    AND             reduce using rule 122 (addCteTable -> .)
    OR              reduce using rule 122 (addCteTable -> .)
    RPAREN          reduce using rule 122 (addCteTable -> .)
    COMMA           reduce using rule 122 (addCteTable -> .)
    SCOLON          reduce using rule 122 (addCteTable -> .)
    TO              reduce using rule 122 (addCteTable -> .)
    DO              reduce using rule 122 (addCteTable -> .)
    RBRACK          reduce using rule 122 (addCteTable -> .)

    addCteTable                    shift and go to state 175

state 145

    (118) f -> CTE_F . addCteTable step1
    (122) addCteTable -> .

    MULT            reduce using rule 122 (addCteTable -> .)
    DIV             reduce using rule 122 (addCteTable -> .)
    PLUS            reduce using rule 122 (addCteTable -> .)
    MINUS           reduce using rule 122 (addCteTable -> .)
    LT              reduce using rule 122 (addCteTable -> .)
    GT              reduce using rule 122 (addCteTable -> .)
    LTE             reduce using rule 122 (addCteTable -> .)
    GTE             reduce using rule 122 (addCteTable -> .)
    EQUALS          reduce using rule 122 (addCteTable -> .)
    NEQUALS         reduce using rule 122 (addCteTable -> .)
    AND             reduce using rule 122 (addCteTable -> .)
    OR              reduce using rule 122 (addCteTable -> .)
    RPAREN          reduce using rule 122 (addCteTable -> .)
    COMMA           reduce using rule 122 (addCteTable -> .)
    SCOLON          reduce using rule 122 (addCteTable -> .)
    TO              reduce using rule 122 (addCteTable -> .)
    DO              reduce using rule 122 (addCteTable -> .)
    RBRACK          reduce using rule 122 (addCteTable -> .)

    addCteTable                    shift and go to state 176

state 146

    (119) f -> CTE_C . addCteTable step1
    (122) addCteTable -> .

    MULT            reduce using rule 122 (addCteTable -> .)
    DIV             reduce using rule 122 (addCteTable -> .)
    PLUS            reduce using rule 122 (addCteTable -> .)
    MINUS           reduce using rule 122 (addCteTable -> .)
    LT              reduce using rule 122 (addCteTable -> .)
    GT              reduce using rule 122 (addCteTable -> .)
    LTE             reduce using rule 122 (addCteTable -> .)
    GTE             reduce using rule 122 (addCteTable -> .)
    EQUALS          reduce using rule 122 (addCteTable -> .)
    NEQUALS         reduce using rule 122 (addCteTable -> .)
    AND             reduce using rule 122 (addCteTable -> .)
    OR              reduce using rule 122 (addCteTable -> .)
    RPAREN          reduce using rule 122 (addCteTable -> .)
    COMMA           reduce using rule 122 (addCteTable -> .)
    SCOLON          reduce using rule 122 (addCteTable -> .)
    TO              reduce using rule 122 (addCteTable -> .)
    DO              reduce using rule 122 (addCteTable -> .)
    RBRACK          reduce using rule 122 (addCteTable -> .)

    addCteTable                    shift and go to state 177

state 147

    (120) f -> llamada .

    MULT            reduce using rule 120 (f -> llamada .)
    DIV             reduce using rule 120 (f -> llamada .)
    PLUS            reduce using rule 120 (f -> llamada .)
    MINUS           reduce using rule 120 (f -> llamada .)
    LT              reduce using rule 120 (f -> llamada .)
    GT              reduce using rule 120 (f -> llamada .)
    LTE             reduce using rule 120 (f -> llamada .)
    GTE             reduce using rule 120 (f -> llamada .)
    EQUALS          reduce using rule 120 (f -> llamada .)
    NEQUALS         reduce using rule 120 (f -> llamada .)
    AND             reduce using rule 120 (f -> llamada .)
    OR              reduce using rule 120 (f -> llamada .)
    RPAREN          reduce using rule 120 (f -> llamada .)
    COMMA           reduce using rule 120 (f -> llamada .)
    SCOLON          reduce using rule 120 (f -> llamada .)
    TO              reduce using rule 120 (f -> llamada .)
    DO              reduce using rule 120 (f -> llamada .)
    RBRACK          reduce using rule 120 (f -> llamada .)


state 148

    (121) f -> idCall .

    MULT            reduce using rule 121 (f -> idCall .)
    DIV             reduce using rule 121 (f -> idCall .)
    PLUS            reduce using rule 121 (f -> idCall .)
    MINUS           reduce using rule 121 (f -> idCall .)
    LT              reduce using rule 121 (f -> idCall .)
    GT              reduce using rule 121 (f -> idCall .)
    LTE             reduce using rule 121 (f -> idCall .)
    GTE             reduce using rule 121 (f -> idCall .)
    EQUALS          reduce using rule 121 (f -> idCall .)
    NEQUALS         reduce using rule 121 (f -> idCall .)
    AND             reduce using rule 121 (f -> idCall .)
    OR              reduce using rule 121 (f -> idCall .)
    RPAREN          reduce using rule 121 (f -> idCall .)
    COMMA           reduce using rule 121 (f -> idCall .)
    SCOLON          reduce using rule 121 (f -> idCall .)
    TO              reduce using rule 121 (f -> idCall .)
    DO              reduce using rule 121 (f -> idCall .)
    RBRACK          reduce using rule 121 (f -> idCall .)


state 149

    (93) cond_w -> WHILE step1While LPAREN . exp RPAREN step2While DO LBRACE listaEstatutos RBRACE step3While
    (99) exp -> . texp step7
    (100) exp -> . texp step7 OR pushPoper exp
    (101) texp -> . gexp step6
    (102) texp -> . gexp step6 AND pushPoper texp
    (103) gexp -> . mexp step5
    (104) gexp -> . mexp step5 LT pushPoper gexp
    (105) gexp -> . mexp step5 GT pushPoper gexp
    (106) gexp -> . mexp step5 LTE pushPoper gexp
    (107) gexp -> . mexp step5 GTE pushPoper gexp
    (108) gexp -> . mexp step5 EQUALS pushPoper gexp
    (109) gexp -> . mexp step5 NEQUALS pushPoper gexp
    (110) mexp -> . t step4
    (111) mexp -> . t step4 PLUS pushPoper mexp
    (112) mexp -> . t step4 MINUS pushPoper mexp
    (113) t -> . f step3
    (114) t -> . f step3 MULT pushPoper t
    (115) t -> . f step3 DIV pushPoper t
    (116) f -> . LPAREN addFF exp RPAREN rmFF
    (117) f -> . CTE_I addCteTable step1
    (118) f -> . CTE_F addCteTable step1
    (119) f -> . CTE_C addCteTable step1
    (120) f -> . llamada
    (121) f -> . idCall
    (65) llamada -> . ID DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> . ID verExist LPAREN enviaParam coherenceGo RPAREN
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    LPAREN          shift and go to state 137
    CTE_I           shift and go to state 144
    CTE_F           shift and go to state 145
    CTE_C           shift and go to state 146
    ID              shift and go to state 81

    exp                            shift and go to state 178
    texp                           shift and go to state 139
    gexp                           shift and go to state 140
    mexp                           shift and go to state 141
    t                              shift and go to state 142
    f                              shift and go to state 143
    llamada                        shift and go to state 147
    idCall                         shift and go to state 148

state 150

    (97) cond_f -> FOR asignacion TO . exp step1While step1For step2While DO LBRACE listaEstatutos RBRACE step3While
    (99) exp -> . texp step7
    (100) exp -> . texp step7 OR pushPoper exp
    (101) texp -> . gexp step6
    (102) texp -> . gexp step6 AND pushPoper texp
    (103) gexp -> . mexp step5
    (104) gexp -> . mexp step5 LT pushPoper gexp
    (105) gexp -> . mexp step5 GT pushPoper gexp
    (106) gexp -> . mexp step5 LTE pushPoper gexp
    (107) gexp -> . mexp step5 GTE pushPoper gexp
    (108) gexp -> . mexp step5 EQUALS pushPoper gexp
    (109) gexp -> . mexp step5 NEQUALS pushPoper gexp
    (110) mexp -> . t step4
    (111) mexp -> . t step4 PLUS pushPoper mexp
    (112) mexp -> . t step4 MINUS pushPoper mexp
    (113) t -> . f step3
    (114) t -> . f step3 MULT pushPoper t
    (115) t -> . f step3 DIV pushPoper t
    (116) f -> . LPAREN addFF exp RPAREN rmFF
    (117) f -> . CTE_I addCteTable step1
    (118) f -> . CTE_F addCteTable step1
    (119) f -> . CTE_C addCteTable step1
    (120) f -> . llamada
    (121) f -> . idCall
    (65) llamada -> . ID DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> . ID verExist LPAREN enviaParam coherenceGo RPAREN
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    LPAREN          shift and go to state 137
    CTE_I           shift and go to state 144
    CTE_F           shift and go to state 145
    CTE_C           shift and go to state 146
    ID              shift and go to state 81

    exp                            shift and go to state 179
    texp                           shift and go to state 139
    gexp                           shift and go to state 140
    mexp                           shift and go to state 141
    t                              shift and go to state 142
    f                              shift and go to state 143
    llamada                        shift and go to state 147
    idCall                         shift and go to state 148

state 151

    (48) definFunc -> tipoMethod FUNC ID auxFuncion LPAREN listaParam RPAREN declarVar setDI LBRACE . listaEstatutos RBRACE endF definFunc
    (53) listaEstatutos -> . estatutos listaEstatutos
    (54) listaEstatutos -> . empty
    (55) estatutos -> . llamada SCOLON
    (56) estatutos -> . asignacion SCOLON
    (57) estatutos -> . returnf SCOLON
    (58) estatutos -> . lectura SCOLON
    (59) estatutos -> . escritura SCOLON
    (60) estatutos -> . condicion
    (61) estatutos -> . cond_w
    (62) estatutos -> . cond_f
    (132) empty -> .
    (65) llamada -> . ID DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> . ID verExist LPAREN enviaParam coherenceGo RPAREN
    (63) asignacion -> . idCall ASIGNA pushPoper exp asignStep2
    (75) returnf -> . RETURN pushPoper LPAREN exp RPAREN popReturn
    (77) lectura -> . READ pushPoper LPAREN listaId RPAREN
    (82) escritura -> . WRITE pushPoper LPAREN exp popIO lextra RPAREN
    (83) escritura -> . WRITE pushPoper LPAREN LETRERO letreroPush popIO lextra RPAREN
    (89) condicion -> . IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE
    (90) condicion -> . IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE ELSE cond3 LBRACE listaEstatutos RBRACE
    (93) cond_w -> . WHILE step1While LPAREN exp RPAREN step2While DO LBRACE listaEstatutos RBRACE step3While
    (97) cond_f -> . FOR asignacion TO exp step1While step1For step2While DO LBRACE listaEstatutos RBRACE step3While
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    RBRACE          reduce using rule 132 (empty -> .)
    ID              shift and go to state 81
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    WHILE           shift and go to state 98
    FOR             shift and go to state 99

    listaEstatutos                 shift and go to state 180
    estatutos                      shift and go to state 83
    empty                          shift and go to state 84
    llamada                        shift and go to state 85
    asignacion                     shift and go to state 86
    returnf                        shift and go to state 87
    lectura                        shift and go to state 88
    escritura                      shift and go to state 89
    condicion                      shift and go to state 90
    cond_w                         shift and go to state 91
    cond_f                         shift and go to state 92
    idCall                         shift and go to state 93

state 152

    (16) idDeclare -> ID auxDeclare LBRACK CTE_I addCteTable COMMA CTE_I addCteTable auxCTE2 . RBRACK

    RBRACK          shift and go to state 181


state 153

    (40) declarMethods -> tipoMethod FUNC ID LPAREN listaParam RPAREN . LBRACE listaEstatutos RBRACE declarMethods

    LBRACE          shift and go to state 182


state 154

    (65) llamada -> ID DOT ID LPAREN . enviaParam RPAREN
    (67) enviaParam -> . paramReferencia
    (68) enviaParam -> . empty
    (69) paramReferencia -> . exp paramType
    (70) paramReferencia -> . exp paramType COMMA paramCount paramReferencia
    (132) empty -> .
    (99) exp -> . texp step7
    (100) exp -> . texp step7 OR pushPoper exp
    (101) texp -> . gexp step6
    (102) texp -> . gexp step6 AND pushPoper texp
    (103) gexp -> . mexp step5
    (104) gexp -> . mexp step5 LT pushPoper gexp
    (105) gexp -> . mexp step5 GT pushPoper gexp
    (106) gexp -> . mexp step5 LTE pushPoper gexp
    (107) gexp -> . mexp step5 GTE pushPoper gexp
    (108) gexp -> . mexp step5 EQUALS pushPoper gexp
    (109) gexp -> . mexp step5 NEQUALS pushPoper gexp
    (110) mexp -> . t step4
    (111) mexp -> . t step4 PLUS pushPoper mexp
    (112) mexp -> . t step4 MINUS pushPoper mexp
    (113) t -> . f step3
    (114) t -> . f step3 MULT pushPoper t
    (115) t -> . f step3 DIV pushPoper t
    (116) f -> . LPAREN addFF exp RPAREN rmFF
    (117) f -> . CTE_I addCteTable step1
    (118) f -> . CTE_F addCteTable step1
    (119) f -> . CTE_C addCteTable step1
    (120) f -> . llamada
    (121) f -> . idCall
    (65) llamada -> . ID DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> . ID verExist LPAREN enviaParam coherenceGo RPAREN
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    RPAREN          reduce using rule 132 (empty -> .)
    LPAREN          shift and go to state 137
    CTE_I           shift and go to state 144
    CTE_F           shift and go to state 145
    CTE_C           shift and go to state 146
    ID              shift and go to state 81

    enviaParam                     shift and go to state 183
    paramReferencia                shift and go to state 156
    empty                          shift and go to state 157
    exp                            shift and go to state 158
    texp                           shift and go to state 139
    gexp                           shift and go to state 140
    mexp                           shift and go to state 141
    t                              shift and go to state 142
    f                              shift and go to state 143
    llamada                        shift and go to state 147
    idCall                         shift and go to state 148

state 155

    (66) llamada -> ID verExist LPAREN enviaParam . coherenceGo RPAREN
    (74) coherenceGo -> .

    RPAREN          reduce using rule 74 (coherenceGo -> .)

    coherenceGo                    shift and go to state 184

state 156

    (67) enviaParam -> paramReferencia .

    RPAREN          reduce using rule 67 (enviaParam -> paramReferencia .)


state 157

    (68) enviaParam -> empty .

    RPAREN          reduce using rule 68 (enviaParam -> empty .)


state 158

    (69) paramReferencia -> exp . paramType
    (70) paramReferencia -> exp . paramType COMMA paramCount paramReferencia
    (72) paramType -> .

    COMMA           reduce using rule 72 (paramType -> .)
    RPAREN          reduce using rule 72 (paramType -> .)

    paramType                      shift and go to state 185

state 159

    (22) idCall -> ID idCallaux DOT ID .

    ASIGNA          reduce using rule 22 (idCall -> ID idCallaux DOT ID .)
    MULT            reduce using rule 22 (idCall -> ID idCallaux DOT ID .)
    DIV             reduce using rule 22 (idCall -> ID idCallaux DOT ID .)
    PLUS            reduce using rule 22 (idCall -> ID idCallaux DOT ID .)
    MINUS           reduce using rule 22 (idCall -> ID idCallaux DOT ID .)
    LT              reduce using rule 22 (idCall -> ID idCallaux DOT ID .)
    GT              reduce using rule 22 (idCall -> ID idCallaux DOT ID .)
    LTE             reduce using rule 22 (idCall -> ID idCallaux DOT ID .)
    GTE             reduce using rule 22 (idCall -> ID idCallaux DOT ID .)
    EQUALS          reduce using rule 22 (idCall -> ID idCallaux DOT ID .)
    NEQUALS         reduce using rule 22 (idCall -> ID idCallaux DOT ID .)
    AND             reduce using rule 22 (idCall -> ID idCallaux DOT ID .)
    OR              reduce using rule 22 (idCall -> ID idCallaux DOT ID .)
    RPAREN          reduce using rule 22 (idCall -> ID idCallaux DOT ID .)
    COMMA           reduce using rule 22 (idCall -> ID idCallaux DOT ID .)
    SCOLON          reduce using rule 22 (idCall -> ID idCallaux DOT ID .)
    TO              reduce using rule 22 (idCall -> ID idCallaux DOT ID .)
    DO              reduce using rule 22 (idCall -> ID idCallaux DOT ID .)
    RBRACK          reduce using rule 22 (idCall -> ID idCallaux DOT ID .)


state 160

    (23) idCall -> ID idCallaux LBRACK addFF . exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> ID idCallaux LBRACK addFF . exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2
    (99) exp -> . texp step7
    (100) exp -> . texp step7 OR pushPoper exp
    (101) texp -> . gexp step6
    (102) texp -> . gexp step6 AND pushPoper texp
    (103) gexp -> . mexp step5
    (104) gexp -> . mexp step5 LT pushPoper gexp
    (105) gexp -> . mexp step5 GT pushPoper gexp
    (106) gexp -> . mexp step5 LTE pushPoper gexp
    (107) gexp -> . mexp step5 GTE pushPoper gexp
    (108) gexp -> . mexp step5 EQUALS pushPoper gexp
    (109) gexp -> . mexp step5 NEQUALS pushPoper gexp
    (110) mexp -> . t step4
    (111) mexp -> . t step4 PLUS pushPoper mexp
    (112) mexp -> . t step4 MINUS pushPoper mexp
    (113) t -> . f step3
    (114) t -> . f step3 MULT pushPoper t
    (115) t -> . f step3 DIV pushPoper t
    (116) f -> . LPAREN addFF exp RPAREN rmFF
    (117) f -> . CTE_I addCteTable step1
    (118) f -> . CTE_F addCteTable step1
    (119) f -> . CTE_C addCteTable step1
    (120) f -> . llamada
    (121) f -> . idCall
    (65) llamada -> . ID DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> . ID verExist LPAREN enviaParam coherenceGo RPAREN
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    LPAREN          shift and go to state 137
    CTE_I           shift and go to state 144
    CTE_F           shift and go to state 145
    CTE_C           shift and go to state 146
    ID              shift and go to state 81

    exp                            shift and go to state 186
    texp                           shift and go to state 139
    gexp                           shift and go to state 140
    mexp                           shift and go to state 141
    t                              shift and go to state 142
    f                              shift and go to state 143
    llamada                        shift and go to state 147
    idCall                         shift and go to state 148

state 161

    (1) program -> PROGRAM ID initProg SCOLON declarClases declarVar addGlobSize definFunc MAIN auxMain LPAREN RPAREN declarVar LBRACE listaEstatutos RBRACE endProg prueba .

    $end            reduce using rule 1 (program -> PROGRAM ID initProg SCOLON declarClases declarVar addGlobSize definFunc MAIN auxMain LPAREN RPAREN declarVar LBRACE listaEstatutos RBRACE endProg prueba .)


state 162

    (63) asignacion -> idCall ASIGNA pushPoper exp . asignStep2
    (64) asignStep2 -> .

    SCOLON          reduce using rule 64 (asignStep2 -> .)
    TO              reduce using rule 64 (asignStep2 -> .)

    asignStep2                     shift and go to state 187

state 163

    (75) returnf -> RETURN pushPoper LPAREN exp . RPAREN popReturn

    RPAREN          shift and go to state 188


state 164

    (77) lectura -> READ pushPoper LPAREN listaId . RPAREN

    RPAREN          shift and go to state 189


state 165

    (78) listaId -> idCall . popIO
    (79) listaId -> idCall . COMMA popIO insertOpRead listaId
    (81) popIO -> .

    COMMA           shift and go to state 191
    RPAREN          reduce using rule 81 (popIO -> .)

    popIO                          shift and go to state 190

state 166

    (82) escritura -> WRITE pushPoper LPAREN exp . popIO lextra RPAREN
    (81) popIO -> .

    COMMA           reduce using rule 81 (popIO -> .)
    RPAREN          reduce using rule 81 (popIO -> .)

    popIO                          shift and go to state 192

state 167

    (83) escritura -> WRITE pushPoper LPAREN LETRERO . letreroPush popIO lextra RPAREN
    (88) letreroPush -> .

    COMMA           reduce using rule 88 (letreroPush -> .)
    RPAREN          reduce using rule 88 (letreroPush -> .)

    letreroPush                    shift and go to state 193

state 168

    (116) f -> LPAREN addFF . exp RPAREN rmFF
    (99) exp -> . texp step7
    (100) exp -> . texp step7 OR pushPoper exp
    (101) texp -> . gexp step6
    (102) texp -> . gexp step6 AND pushPoper texp
    (103) gexp -> . mexp step5
    (104) gexp -> . mexp step5 LT pushPoper gexp
    (105) gexp -> . mexp step5 GT pushPoper gexp
    (106) gexp -> . mexp step5 LTE pushPoper gexp
    (107) gexp -> . mexp step5 GTE pushPoper gexp
    (108) gexp -> . mexp step5 EQUALS pushPoper gexp
    (109) gexp -> . mexp step5 NEQUALS pushPoper gexp
    (110) mexp -> . t step4
    (111) mexp -> . t step4 PLUS pushPoper mexp
    (112) mexp -> . t step4 MINUS pushPoper mexp
    (113) t -> . f step3
    (114) t -> . f step3 MULT pushPoper t
    (115) t -> . f step3 DIV pushPoper t
    (116) f -> . LPAREN addFF exp RPAREN rmFF
    (117) f -> . CTE_I addCteTable step1
    (118) f -> . CTE_F addCteTable step1
    (119) f -> . CTE_C addCteTable step1
    (120) f -> . llamada
    (121) f -> . idCall
    (65) llamada -> . ID DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> . ID verExist LPAREN enviaParam coherenceGo RPAREN
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    LPAREN          shift and go to state 137
    CTE_I           shift and go to state 144
    CTE_F           shift and go to state 145
    CTE_C           shift and go to state 146
    ID              shift and go to state 81

    exp                            shift and go to state 194
    texp                           shift and go to state 139
    gexp                           shift and go to state 140
    mexp                           shift and go to state 141
    t                              shift and go to state 142
    f                              shift and go to state 143
    llamada                        shift and go to state 147
    idCall                         shift and go to state 148

state 169

    (89) condicion -> IF LPAREN exp RPAREN . cond1 THEN LBRACE listaEstatutos RBRACE
    (90) condicion -> IF LPAREN exp RPAREN . cond1 THEN LBRACE listaEstatutos RBRACE ELSE cond3 LBRACE listaEstatutos RBRACE
    (91) cond1 -> .

    THEN            reduce using rule 91 (cond1 -> .)

    cond1                          shift and go to state 195

state 170

    (99) exp -> texp step7 .
    (100) exp -> texp step7 . OR pushPoper exp

    RPAREN          reduce using rule 99 (exp -> texp step7 .)
    COMMA           reduce using rule 99 (exp -> texp step7 .)
    SCOLON          reduce using rule 99 (exp -> texp step7 .)
    TO              reduce using rule 99 (exp -> texp step7 .)
    DO              reduce using rule 99 (exp -> texp step7 .)
    RBRACK          reduce using rule 99 (exp -> texp step7 .)
    OR              shift and go to state 196


state 171

    (101) texp -> gexp step6 .
    (102) texp -> gexp step6 . AND pushPoper texp

    OR              reduce using rule 101 (texp -> gexp step6 .)
    RPAREN          reduce using rule 101 (texp -> gexp step6 .)
    COMMA           reduce using rule 101 (texp -> gexp step6 .)
    SCOLON          reduce using rule 101 (texp -> gexp step6 .)
    TO              reduce using rule 101 (texp -> gexp step6 .)
    DO              reduce using rule 101 (texp -> gexp step6 .)
    RBRACK          reduce using rule 101 (texp -> gexp step6 .)
    AND             shift and go to state 197


state 172

    (103) gexp -> mexp step5 .
    (104) gexp -> mexp step5 . LT pushPoper gexp
    (105) gexp -> mexp step5 . GT pushPoper gexp
    (106) gexp -> mexp step5 . LTE pushPoper gexp
    (107) gexp -> mexp step5 . GTE pushPoper gexp
    (108) gexp -> mexp step5 . EQUALS pushPoper gexp
    (109) gexp -> mexp step5 . NEQUALS pushPoper gexp

    AND             reduce using rule 103 (gexp -> mexp step5 .)
    OR              reduce using rule 103 (gexp -> mexp step5 .)
    RPAREN          reduce using rule 103 (gexp -> mexp step5 .)
    COMMA           reduce using rule 103 (gexp -> mexp step5 .)
    SCOLON          reduce using rule 103 (gexp -> mexp step5 .)
    TO              reduce using rule 103 (gexp -> mexp step5 .)
    DO              reduce using rule 103 (gexp -> mexp step5 .)
    RBRACK          reduce using rule 103 (gexp -> mexp step5 .)
    LT              shift and go to state 198
    GT              shift and go to state 199
    LTE             shift and go to state 200
    GTE             shift and go to state 201
    EQUALS          shift and go to state 202
    NEQUALS         shift and go to state 203


state 173

    (110) mexp -> t step4 .
    (111) mexp -> t step4 . PLUS pushPoper mexp
    (112) mexp -> t step4 . MINUS pushPoper mexp

    LT              reduce using rule 110 (mexp -> t step4 .)
    GT              reduce using rule 110 (mexp -> t step4 .)
    LTE             reduce using rule 110 (mexp -> t step4 .)
    GTE             reduce using rule 110 (mexp -> t step4 .)
    EQUALS          reduce using rule 110 (mexp -> t step4 .)
    NEQUALS         reduce using rule 110 (mexp -> t step4 .)
    AND             reduce using rule 110 (mexp -> t step4 .)
    OR              reduce using rule 110 (mexp -> t step4 .)
    RPAREN          reduce using rule 110 (mexp -> t step4 .)
    COMMA           reduce using rule 110 (mexp -> t step4 .)
    SCOLON          reduce using rule 110 (mexp -> t step4 .)
    TO              reduce using rule 110 (mexp -> t step4 .)
    DO              reduce using rule 110 (mexp -> t step4 .)
    RBRACK          reduce using rule 110 (mexp -> t step4 .)
    PLUS            shift and go to state 204
    MINUS           shift and go to state 205


state 174

    (113) t -> f step3 .
    (114) t -> f step3 . MULT pushPoper t
    (115) t -> f step3 . DIV pushPoper t

    PLUS            reduce using rule 113 (t -> f step3 .)
    MINUS           reduce using rule 113 (t -> f step3 .)
    LT              reduce using rule 113 (t -> f step3 .)
    GT              reduce using rule 113 (t -> f step3 .)
    LTE             reduce using rule 113 (t -> f step3 .)
    GTE             reduce using rule 113 (t -> f step3 .)
    EQUALS          reduce using rule 113 (t -> f step3 .)
    NEQUALS         reduce using rule 113 (t -> f step3 .)
    AND             reduce using rule 113 (t -> f step3 .)
    OR              reduce using rule 113 (t -> f step3 .)
    RPAREN          reduce using rule 113 (t -> f step3 .)
    COMMA           reduce using rule 113 (t -> f step3 .)
    SCOLON          reduce using rule 113 (t -> f step3 .)
    TO              reduce using rule 113 (t -> f step3 .)
    DO              reduce using rule 113 (t -> f step3 .)
    RBRACK          reduce using rule 113 (t -> f step3 .)
    MULT            shift and go to state 206
    DIV             shift and go to state 207


state 175

    (117) f -> CTE_I addCteTable . step1
    (123) step1 -> .

    MULT            reduce using rule 123 (step1 -> .)
    DIV             reduce using rule 123 (step1 -> .)
    PLUS            reduce using rule 123 (step1 -> .)
    MINUS           reduce using rule 123 (step1 -> .)
    LT              reduce using rule 123 (step1 -> .)
    GT              reduce using rule 123 (step1 -> .)
    LTE             reduce using rule 123 (step1 -> .)
    GTE             reduce using rule 123 (step1 -> .)
    EQUALS          reduce using rule 123 (step1 -> .)
    NEQUALS         reduce using rule 123 (step1 -> .)
    AND             reduce using rule 123 (step1 -> .)
    OR              reduce using rule 123 (step1 -> .)
    RPAREN          reduce using rule 123 (step1 -> .)
    COMMA           reduce using rule 123 (step1 -> .)
    SCOLON          reduce using rule 123 (step1 -> .)
    TO              reduce using rule 123 (step1 -> .)
    DO              reduce using rule 123 (step1 -> .)
    RBRACK          reduce using rule 123 (step1 -> .)

    step1                          shift and go to state 208

state 176

    (118) f -> CTE_F addCteTable . step1
    (123) step1 -> .

    MULT            reduce using rule 123 (step1 -> .)
    DIV             reduce using rule 123 (step1 -> .)
    PLUS            reduce using rule 123 (step1 -> .)
    MINUS           reduce using rule 123 (step1 -> .)
    LT              reduce using rule 123 (step1 -> .)
    GT              reduce using rule 123 (step1 -> .)
    LTE             reduce using rule 123 (step1 -> .)
    GTE             reduce using rule 123 (step1 -> .)
    EQUALS          reduce using rule 123 (step1 -> .)
    NEQUALS         reduce using rule 123 (step1 -> .)
    AND             reduce using rule 123 (step1 -> .)
    OR              reduce using rule 123 (step1 -> .)
    RPAREN          reduce using rule 123 (step1 -> .)
    COMMA           reduce using rule 123 (step1 -> .)
    SCOLON          reduce using rule 123 (step1 -> .)
    TO              reduce using rule 123 (step1 -> .)
    DO              reduce using rule 123 (step1 -> .)
    RBRACK          reduce using rule 123 (step1 -> .)

    step1                          shift and go to state 209

state 177

    (119) f -> CTE_C addCteTable . step1
    (123) step1 -> .

    MULT            reduce using rule 123 (step1 -> .)
    DIV             reduce using rule 123 (step1 -> .)
    PLUS            reduce using rule 123 (step1 -> .)
    MINUS           reduce using rule 123 (step1 -> .)
    LT              reduce using rule 123 (step1 -> .)
    GT              reduce using rule 123 (step1 -> .)
    LTE             reduce using rule 123 (step1 -> .)
    GTE             reduce using rule 123 (step1 -> .)
    EQUALS          reduce using rule 123 (step1 -> .)
    NEQUALS         reduce using rule 123 (step1 -> .)
    AND             reduce using rule 123 (step1 -> .)
    OR              reduce using rule 123 (step1 -> .)
    RPAREN          reduce using rule 123 (step1 -> .)
    COMMA           reduce using rule 123 (step1 -> .)
    SCOLON          reduce using rule 123 (step1 -> .)
    TO              reduce using rule 123 (step1 -> .)
    DO              reduce using rule 123 (step1 -> .)
    RBRACK          reduce using rule 123 (step1 -> .)

    step1                          shift and go to state 210

state 178

    (93) cond_w -> WHILE step1While LPAREN exp . RPAREN step2While DO LBRACE listaEstatutos RBRACE step3While

    RPAREN          shift and go to state 211


state 179

    (97) cond_f -> FOR asignacion TO exp . step1While step1For step2While DO LBRACE listaEstatutos RBRACE step3While
    (94) step1While -> .

    DO              reduce using rule 94 (step1While -> .)

    step1While                     shift and go to state 212

state 180

    (48) definFunc -> tipoMethod FUNC ID auxFuncion LPAREN listaParam RPAREN declarVar setDI LBRACE listaEstatutos . RBRACE endF definFunc

    RBRACE          shift and go to state 213


state 181

    (16) idDeclare -> ID auxDeclare LBRACK CTE_I addCteTable COMMA CTE_I addCteTable auxCTE2 RBRACK .

    COMMA           reduce using rule 16 (idDeclare -> ID auxDeclare LBRACK CTE_I addCteTable COMMA CTE_I addCteTable auxCTE2 RBRACK .)
    SCOLON          reduce using rule 16 (idDeclare -> ID auxDeclare LBRACK CTE_I addCteTable COMMA CTE_I addCteTable auxCTE2 RBRACK .)


state 182

    (40) declarMethods -> tipoMethod FUNC ID LPAREN listaParam RPAREN LBRACE . listaEstatutos RBRACE declarMethods
    (53) listaEstatutos -> . estatutos listaEstatutos
    (54) listaEstatutos -> . empty
    (55) estatutos -> . llamada SCOLON
    (56) estatutos -> . asignacion SCOLON
    (57) estatutos -> . returnf SCOLON
    (58) estatutos -> . lectura SCOLON
    (59) estatutos -> . escritura SCOLON
    (60) estatutos -> . condicion
    (61) estatutos -> . cond_w
    (62) estatutos -> . cond_f
    (132) empty -> .
    (65) llamada -> . ID DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> . ID verExist LPAREN enviaParam coherenceGo RPAREN
    (63) asignacion -> . idCall ASIGNA pushPoper exp asignStep2
    (75) returnf -> . RETURN pushPoper LPAREN exp RPAREN popReturn
    (77) lectura -> . READ pushPoper LPAREN listaId RPAREN
    (82) escritura -> . WRITE pushPoper LPAREN exp popIO lextra RPAREN
    (83) escritura -> . WRITE pushPoper LPAREN LETRERO letreroPush popIO lextra RPAREN
    (89) condicion -> . IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE
    (90) condicion -> . IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE ELSE cond3 LBRACE listaEstatutos RBRACE
    (93) cond_w -> . WHILE step1While LPAREN exp RPAREN step2While DO LBRACE listaEstatutos RBRACE step3While
    (97) cond_f -> . FOR asignacion TO exp step1While step1For step2While DO LBRACE listaEstatutos RBRACE step3While
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    RBRACE          reduce using rule 132 (empty -> .)
    ID              shift and go to state 81
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    WHILE           shift and go to state 98
    FOR             shift and go to state 99

    listaEstatutos                 shift and go to state 214
    estatutos                      shift and go to state 83
    empty                          shift and go to state 84
    llamada                        shift and go to state 85
    asignacion                     shift and go to state 86
    returnf                        shift and go to state 87
    lectura                        shift and go to state 88
    escritura                      shift and go to state 89
    condicion                      shift and go to state 90
    cond_w                         shift and go to state 91
    cond_f                         shift and go to state 92
    idCall                         shift and go to state 93

state 183

    (65) llamada -> ID DOT ID LPAREN enviaParam . RPAREN

    RPAREN          shift and go to state 215


state 184

    (66) llamada -> ID verExist LPAREN enviaParam coherenceGo . RPAREN

    RPAREN          shift and go to state 216


state 185

    (69) paramReferencia -> exp paramType .
    (70) paramReferencia -> exp paramType . COMMA paramCount paramReferencia

    RPAREN          reduce using rule 69 (paramReferencia -> exp paramType .)
    COMMA           shift and go to state 217


state 186

    (23) idCall -> ID idCallaux LBRACK addFF exp . RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> ID idCallaux LBRACK addFF exp . idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2
    (26) idCallaux2 -> .

    RBRACK          shift and go to state 218
    COMMA           reduce using rule 26 (idCallaux2 -> .)

    idCallaux2                     shift and go to state 219

state 187

    (63) asignacion -> idCall ASIGNA pushPoper exp asignStep2 .

    SCOLON          reduce using rule 63 (asignacion -> idCall ASIGNA pushPoper exp asignStep2 .)
    TO              reduce using rule 63 (asignacion -> idCall ASIGNA pushPoper exp asignStep2 .)


state 188

    (75) returnf -> RETURN pushPoper LPAREN exp RPAREN . popReturn
    (76) popReturn -> .

    SCOLON          reduce using rule 76 (popReturn -> .)

    popReturn                      shift and go to state 220

state 189

    (77) lectura -> READ pushPoper LPAREN listaId RPAREN .

    SCOLON          reduce using rule 77 (lectura -> READ pushPoper LPAREN listaId RPAREN .)


state 190

    (78) listaId -> idCall popIO .

    RPAREN          reduce using rule 78 (listaId -> idCall popIO .)


state 191

    (79) listaId -> idCall COMMA . popIO insertOpRead listaId
    (81) popIO -> .

    ID              reduce using rule 81 (popIO -> .)

    popIO                          shift and go to state 221

state 192

    (82) escritura -> WRITE pushPoper LPAREN exp popIO . lextra RPAREN
    (84) lextra -> . COMMA insertOpWrite exp popIO lextra
    (85) lextra -> . COMMA insertOpWrite LETRERO letreroPush popIO lextra
    (86) lextra -> . empty
    (132) empty -> .

    COMMA           shift and go to state 223
    RPAREN          reduce using rule 132 (empty -> .)

    lextra                         shift and go to state 222
    empty                          shift and go to state 224

state 193

    (83) escritura -> WRITE pushPoper LPAREN LETRERO letreroPush . popIO lextra RPAREN
    (81) popIO -> .

    COMMA           reduce using rule 81 (popIO -> .)
    RPAREN          reduce using rule 81 (popIO -> .)

    popIO                          shift and go to state 225

state 194

    (116) f -> LPAREN addFF exp . RPAREN rmFF

    RPAREN          shift and go to state 226


state 195

    (89) condicion -> IF LPAREN exp RPAREN cond1 . THEN LBRACE listaEstatutos RBRACE
    (90) condicion -> IF LPAREN exp RPAREN cond1 . THEN LBRACE listaEstatutos RBRACE ELSE cond3 LBRACE listaEstatutos RBRACE

    THEN            shift and go to state 227


state 196

    (100) exp -> texp step7 OR . pushPoper exp
    (131) pushPoper -> .

    LPAREN          reduce using rule 131 (pushPoper -> .)
    CTE_I           reduce using rule 131 (pushPoper -> .)
    CTE_F           reduce using rule 131 (pushPoper -> .)
    CTE_C           reduce using rule 131 (pushPoper -> .)
    ID              reduce using rule 131 (pushPoper -> .)

    pushPoper                      shift and go to state 228

state 197

    (102) texp -> gexp step6 AND . pushPoper texp
    (131) pushPoper -> .

    LPAREN          reduce using rule 131 (pushPoper -> .)
    CTE_I           reduce using rule 131 (pushPoper -> .)
    CTE_F           reduce using rule 131 (pushPoper -> .)
    CTE_C           reduce using rule 131 (pushPoper -> .)
    ID              reduce using rule 131 (pushPoper -> .)

    pushPoper                      shift and go to state 229

state 198

    (104) gexp -> mexp step5 LT . pushPoper gexp
    (131) pushPoper -> .

    LPAREN          reduce using rule 131 (pushPoper -> .)
    CTE_I           reduce using rule 131 (pushPoper -> .)
    CTE_F           reduce using rule 131 (pushPoper -> .)
    CTE_C           reduce using rule 131 (pushPoper -> .)
    ID              reduce using rule 131 (pushPoper -> .)

    pushPoper                      shift and go to state 230

state 199

    (105) gexp -> mexp step5 GT . pushPoper gexp
    (131) pushPoper -> .

    LPAREN          reduce using rule 131 (pushPoper -> .)
    CTE_I           reduce using rule 131 (pushPoper -> .)
    CTE_F           reduce using rule 131 (pushPoper -> .)
    CTE_C           reduce using rule 131 (pushPoper -> .)
    ID              reduce using rule 131 (pushPoper -> .)

    pushPoper                      shift and go to state 231

state 200

    (106) gexp -> mexp step5 LTE . pushPoper gexp
    (131) pushPoper -> .

    LPAREN          reduce using rule 131 (pushPoper -> .)
    CTE_I           reduce using rule 131 (pushPoper -> .)
    CTE_F           reduce using rule 131 (pushPoper -> .)
    CTE_C           reduce using rule 131 (pushPoper -> .)
    ID              reduce using rule 131 (pushPoper -> .)

    pushPoper                      shift and go to state 232

state 201

    (107) gexp -> mexp step5 GTE . pushPoper gexp
    (131) pushPoper -> .

    LPAREN          reduce using rule 131 (pushPoper -> .)
    CTE_I           reduce using rule 131 (pushPoper -> .)
    CTE_F           reduce using rule 131 (pushPoper -> .)
    CTE_C           reduce using rule 131 (pushPoper -> .)
    ID              reduce using rule 131 (pushPoper -> .)

    pushPoper                      shift and go to state 233

state 202

    (108) gexp -> mexp step5 EQUALS . pushPoper gexp
    (131) pushPoper -> .

    LPAREN          reduce using rule 131 (pushPoper -> .)
    CTE_I           reduce using rule 131 (pushPoper -> .)
    CTE_F           reduce using rule 131 (pushPoper -> .)
    CTE_C           reduce using rule 131 (pushPoper -> .)
    ID              reduce using rule 131 (pushPoper -> .)

    pushPoper                      shift and go to state 234

state 203

    (109) gexp -> mexp step5 NEQUALS . pushPoper gexp
    (131) pushPoper -> .

    LPAREN          reduce using rule 131 (pushPoper -> .)
    CTE_I           reduce using rule 131 (pushPoper -> .)
    CTE_F           reduce using rule 131 (pushPoper -> .)
    CTE_C           reduce using rule 131 (pushPoper -> .)
    ID              reduce using rule 131 (pushPoper -> .)

    pushPoper                      shift and go to state 235

state 204

    (111) mexp -> t step4 PLUS . pushPoper mexp
    (131) pushPoper -> .

    LPAREN          reduce using rule 131 (pushPoper -> .)
    CTE_I           reduce using rule 131 (pushPoper -> .)
    CTE_F           reduce using rule 131 (pushPoper -> .)
    CTE_C           reduce using rule 131 (pushPoper -> .)
    ID              reduce using rule 131 (pushPoper -> .)

    pushPoper                      shift and go to state 236

state 205

    (112) mexp -> t step4 MINUS . pushPoper mexp
    (131) pushPoper -> .

    LPAREN          reduce using rule 131 (pushPoper -> .)
    CTE_I           reduce using rule 131 (pushPoper -> .)
    CTE_F           reduce using rule 131 (pushPoper -> .)
    CTE_C           reduce using rule 131 (pushPoper -> .)
    ID              reduce using rule 131 (pushPoper -> .)

    pushPoper                      shift and go to state 237

state 206

    (114) t -> f step3 MULT . pushPoper t
    (131) pushPoper -> .

    LPAREN          reduce using rule 131 (pushPoper -> .)
    CTE_I           reduce using rule 131 (pushPoper -> .)
    CTE_F           reduce using rule 131 (pushPoper -> .)
    CTE_C           reduce using rule 131 (pushPoper -> .)
    ID              reduce using rule 131 (pushPoper -> .)

    pushPoper                      shift and go to state 238

state 207

    (115) t -> f step3 DIV . pushPoper t
    (131) pushPoper -> .

    LPAREN          reduce using rule 131 (pushPoper -> .)
    CTE_I           reduce using rule 131 (pushPoper -> .)
    CTE_F           reduce using rule 131 (pushPoper -> .)
    CTE_C           reduce using rule 131 (pushPoper -> .)
    ID              reduce using rule 131 (pushPoper -> .)

    pushPoper                      shift and go to state 239

state 208

    (117) f -> CTE_I addCteTable step1 .

    MULT            reduce using rule 117 (f -> CTE_I addCteTable step1 .)
    DIV             reduce using rule 117 (f -> CTE_I addCteTable step1 .)
    PLUS            reduce using rule 117 (f -> CTE_I addCteTable step1 .)
    MINUS           reduce using rule 117 (f -> CTE_I addCteTable step1 .)
    LT              reduce using rule 117 (f -> CTE_I addCteTable step1 .)
    GT              reduce using rule 117 (f -> CTE_I addCteTable step1 .)
    LTE             reduce using rule 117 (f -> CTE_I addCteTable step1 .)
    GTE             reduce using rule 117 (f -> CTE_I addCteTable step1 .)
    EQUALS          reduce using rule 117 (f -> CTE_I addCteTable step1 .)
    NEQUALS         reduce using rule 117 (f -> CTE_I addCteTable step1 .)
    AND             reduce using rule 117 (f -> CTE_I addCteTable step1 .)
    OR              reduce using rule 117 (f -> CTE_I addCteTable step1 .)
    RPAREN          reduce using rule 117 (f -> CTE_I addCteTable step1 .)
    COMMA           reduce using rule 117 (f -> CTE_I addCteTable step1 .)
    SCOLON          reduce using rule 117 (f -> CTE_I addCteTable step1 .)
    TO              reduce using rule 117 (f -> CTE_I addCteTable step1 .)
    DO              reduce using rule 117 (f -> CTE_I addCteTable step1 .)
    RBRACK          reduce using rule 117 (f -> CTE_I addCteTable step1 .)


state 209

    (118) f -> CTE_F addCteTable step1 .

    MULT            reduce using rule 118 (f -> CTE_F addCteTable step1 .)
    DIV             reduce using rule 118 (f -> CTE_F addCteTable step1 .)
    PLUS            reduce using rule 118 (f -> CTE_F addCteTable step1 .)
    MINUS           reduce using rule 118 (f -> CTE_F addCteTable step1 .)
    LT              reduce using rule 118 (f -> CTE_F addCteTable step1 .)
    GT              reduce using rule 118 (f -> CTE_F addCteTable step1 .)
    LTE             reduce using rule 118 (f -> CTE_F addCteTable step1 .)
    GTE             reduce using rule 118 (f -> CTE_F addCteTable step1 .)
    EQUALS          reduce using rule 118 (f -> CTE_F addCteTable step1 .)
    NEQUALS         reduce using rule 118 (f -> CTE_F addCteTable step1 .)
    AND             reduce using rule 118 (f -> CTE_F addCteTable step1 .)
    OR              reduce using rule 118 (f -> CTE_F addCteTable step1 .)
    RPAREN          reduce using rule 118 (f -> CTE_F addCteTable step1 .)
    COMMA           reduce using rule 118 (f -> CTE_F addCteTable step1 .)
    SCOLON          reduce using rule 118 (f -> CTE_F addCteTable step1 .)
    TO              reduce using rule 118 (f -> CTE_F addCteTable step1 .)
    DO              reduce using rule 118 (f -> CTE_F addCteTable step1 .)
    RBRACK          reduce using rule 118 (f -> CTE_F addCteTable step1 .)


state 210

    (119) f -> CTE_C addCteTable step1 .

    MULT            reduce using rule 119 (f -> CTE_C addCteTable step1 .)
    DIV             reduce using rule 119 (f -> CTE_C addCteTable step1 .)
    PLUS            reduce using rule 119 (f -> CTE_C addCteTable step1 .)
    MINUS           reduce using rule 119 (f -> CTE_C addCteTable step1 .)
    LT              reduce using rule 119 (f -> CTE_C addCteTable step1 .)
    GT              reduce using rule 119 (f -> CTE_C addCteTable step1 .)
    LTE             reduce using rule 119 (f -> CTE_C addCteTable step1 .)
    GTE             reduce using rule 119 (f -> CTE_C addCteTable step1 .)
    EQUALS          reduce using rule 119 (f -> CTE_C addCteTable step1 .)
    NEQUALS         reduce using rule 119 (f -> CTE_C addCteTable step1 .)
    AND             reduce using rule 119 (f -> CTE_C addCteTable step1 .)
    OR              reduce using rule 119 (f -> CTE_C addCteTable step1 .)
    RPAREN          reduce using rule 119 (f -> CTE_C addCteTable step1 .)
    COMMA           reduce using rule 119 (f -> CTE_C addCteTable step1 .)
    SCOLON          reduce using rule 119 (f -> CTE_C addCteTable step1 .)
    TO              reduce using rule 119 (f -> CTE_C addCteTable step1 .)
    DO              reduce using rule 119 (f -> CTE_C addCteTable step1 .)
    RBRACK          reduce using rule 119 (f -> CTE_C addCteTable step1 .)


state 211

    (93) cond_w -> WHILE step1While LPAREN exp RPAREN . step2While DO LBRACE listaEstatutos RBRACE step3While
    (95) step2While -> .

    DO              reduce using rule 95 (step2While -> .)

    step2While                     shift and go to state 240

state 212

    (97) cond_f -> FOR asignacion TO exp step1While . step1For step2While DO LBRACE listaEstatutos RBRACE step3While
    (98) step1For -> .

    DO              reduce using rule 98 (step1For -> .)

    step1For                       shift and go to state 241

state 213

    (48) definFunc -> tipoMethod FUNC ID auxFuncion LPAREN listaParam RPAREN declarVar setDI LBRACE listaEstatutos RBRACE . endF definFunc
    (52) endF -> .

    VOID            reduce using rule 52 (endF -> .)
    INT             reduce using rule 52 (endF -> .)
    FLOAT           reduce using rule 52 (endF -> .)
    CHAR            reduce using rule 52 (endF -> .)
    MAIN            reduce using rule 52 (endF -> .)

    endF                           shift and go to state 242

state 214

    (40) declarMethods -> tipoMethod FUNC ID LPAREN listaParam RPAREN LBRACE listaEstatutos . RBRACE declarMethods

    RBRACE          shift and go to state 243


state 215

    (65) llamada -> ID DOT ID LPAREN enviaParam RPAREN .

    SCOLON          reduce using rule 65 (llamada -> ID DOT ID LPAREN enviaParam RPAREN .)
    MULT            reduce using rule 65 (llamada -> ID DOT ID LPAREN enviaParam RPAREN .)
    DIV             reduce using rule 65 (llamada -> ID DOT ID LPAREN enviaParam RPAREN .)
    PLUS            reduce using rule 65 (llamada -> ID DOT ID LPAREN enviaParam RPAREN .)
    MINUS           reduce using rule 65 (llamada -> ID DOT ID LPAREN enviaParam RPAREN .)
    LT              reduce using rule 65 (llamada -> ID DOT ID LPAREN enviaParam RPAREN .)
    GT              reduce using rule 65 (llamada -> ID DOT ID LPAREN enviaParam RPAREN .)
    LTE             reduce using rule 65 (llamada -> ID DOT ID LPAREN enviaParam RPAREN .)
    GTE             reduce using rule 65 (llamada -> ID DOT ID LPAREN enviaParam RPAREN .)
    EQUALS          reduce using rule 65 (llamada -> ID DOT ID LPAREN enviaParam RPAREN .)
    NEQUALS         reduce using rule 65 (llamada -> ID DOT ID LPAREN enviaParam RPAREN .)
    AND             reduce using rule 65 (llamada -> ID DOT ID LPAREN enviaParam RPAREN .)
    OR              reduce using rule 65 (llamada -> ID DOT ID LPAREN enviaParam RPAREN .)
    RPAREN          reduce using rule 65 (llamada -> ID DOT ID LPAREN enviaParam RPAREN .)
    COMMA           reduce using rule 65 (llamada -> ID DOT ID LPAREN enviaParam RPAREN .)
    TO              reduce using rule 65 (llamada -> ID DOT ID LPAREN enviaParam RPAREN .)
    DO              reduce using rule 65 (llamada -> ID DOT ID LPAREN enviaParam RPAREN .)
    RBRACK          reduce using rule 65 (llamada -> ID DOT ID LPAREN enviaParam RPAREN .)


state 216

    (66) llamada -> ID verExist LPAREN enviaParam coherenceGo RPAREN .

    SCOLON          reduce using rule 66 (llamada -> ID verExist LPAREN enviaParam coherenceGo RPAREN .)
    MULT            reduce using rule 66 (llamada -> ID verExist LPAREN enviaParam coherenceGo RPAREN .)
    DIV             reduce using rule 66 (llamada -> ID verExist LPAREN enviaParam coherenceGo RPAREN .)
    PLUS            reduce using rule 66 (llamada -> ID verExist LPAREN enviaParam coherenceGo RPAREN .)
    MINUS           reduce using rule 66 (llamada -> ID verExist LPAREN enviaParam coherenceGo RPAREN .)
    LT              reduce using rule 66 (llamada -> ID verExist LPAREN enviaParam coherenceGo RPAREN .)
    GT              reduce using rule 66 (llamada -> ID verExist LPAREN enviaParam coherenceGo RPAREN .)
    LTE             reduce using rule 66 (llamada -> ID verExist LPAREN enviaParam coherenceGo RPAREN .)
    GTE             reduce using rule 66 (llamada -> ID verExist LPAREN enviaParam coherenceGo RPAREN .)
    EQUALS          reduce using rule 66 (llamada -> ID verExist LPAREN enviaParam coherenceGo RPAREN .)
    NEQUALS         reduce using rule 66 (llamada -> ID verExist LPAREN enviaParam coherenceGo RPAREN .)
    AND             reduce using rule 66 (llamada -> ID verExist LPAREN enviaParam coherenceGo RPAREN .)
    OR              reduce using rule 66 (llamada -> ID verExist LPAREN enviaParam coherenceGo RPAREN .)
    RPAREN          reduce using rule 66 (llamada -> ID verExist LPAREN enviaParam coherenceGo RPAREN .)
    COMMA           reduce using rule 66 (llamada -> ID verExist LPAREN enviaParam coherenceGo RPAREN .)
    TO              reduce using rule 66 (llamada -> ID verExist LPAREN enviaParam coherenceGo RPAREN .)
    DO              reduce using rule 66 (llamada -> ID verExist LPAREN enviaParam coherenceGo RPAREN .)
    RBRACK          reduce using rule 66 (llamada -> ID verExist LPAREN enviaParam coherenceGo RPAREN .)


state 217

    (70) paramReferencia -> exp paramType COMMA . paramCount paramReferencia
    (73) paramCount -> .

    LPAREN          reduce using rule 73 (paramCount -> .)
    CTE_I           reduce using rule 73 (paramCount -> .)
    CTE_F           reduce using rule 73 (paramCount -> .)
    CTE_C           reduce using rule 73 (paramCount -> .)
    ID              reduce using rule 73 (paramCount -> .)

    paramCount                     shift and go to state 244

state 218

    (23) idCall -> ID idCallaux LBRACK addFF exp RBRACK . rmFF idCallaux4 checkDim1
    (130) rmFF -> .

    ASIGNA          reduce using rule 130 (rmFF -> .)
    MULT            reduce using rule 130 (rmFF -> .)
    DIV             reduce using rule 130 (rmFF -> .)
    PLUS            reduce using rule 130 (rmFF -> .)
    MINUS           reduce using rule 130 (rmFF -> .)
    LT              reduce using rule 130 (rmFF -> .)
    GT              reduce using rule 130 (rmFF -> .)
    LTE             reduce using rule 130 (rmFF -> .)
    GTE             reduce using rule 130 (rmFF -> .)
    EQUALS          reduce using rule 130 (rmFF -> .)
    NEQUALS         reduce using rule 130 (rmFF -> .)
    AND             reduce using rule 130 (rmFF -> .)
    OR              reduce using rule 130 (rmFF -> .)
    RPAREN          reduce using rule 130 (rmFF -> .)
    COMMA           reduce using rule 130 (rmFF -> .)
    SCOLON          reduce using rule 130 (rmFF -> .)
    TO              reduce using rule 130 (rmFF -> .)
    DO              reduce using rule 130 (rmFF -> .)
    RBRACK          reduce using rule 130 (rmFF -> .)

    rmFF                           shift and go to state 245

state 219

    (24) idCall -> ID idCallaux LBRACK addFF exp idCallaux2 . rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2
    (130) rmFF -> .

    COMMA           reduce using rule 130 (rmFF -> .)

    rmFF                           shift and go to state 246

state 220

    (75) returnf -> RETURN pushPoper LPAREN exp RPAREN popReturn .

    SCOLON          reduce using rule 75 (returnf -> RETURN pushPoper LPAREN exp RPAREN popReturn .)


state 221

    (79) listaId -> idCall COMMA popIO . insertOpRead listaId
    (80) insertOpRead -> .

    ID              reduce using rule 80 (insertOpRead -> .)

    insertOpRead                   shift and go to state 247

state 222

    (82) escritura -> WRITE pushPoper LPAREN exp popIO lextra . RPAREN

    RPAREN          shift and go to state 248


state 223

    (84) lextra -> COMMA . insertOpWrite exp popIO lextra
    (85) lextra -> COMMA . insertOpWrite LETRERO letreroPush popIO lextra
    (87) insertOpWrite -> .

    LETRERO         reduce using rule 87 (insertOpWrite -> .)
    LPAREN          reduce using rule 87 (insertOpWrite -> .)
    CTE_I           reduce using rule 87 (insertOpWrite -> .)
    CTE_F           reduce using rule 87 (insertOpWrite -> .)
    CTE_C           reduce using rule 87 (insertOpWrite -> .)
    ID              reduce using rule 87 (insertOpWrite -> .)

    insertOpWrite                  shift and go to state 249

state 224

    (86) lextra -> empty .

    RPAREN          reduce using rule 86 (lextra -> empty .)


state 225

    (83) escritura -> WRITE pushPoper LPAREN LETRERO letreroPush popIO . lextra RPAREN
    (84) lextra -> . COMMA insertOpWrite exp popIO lextra
    (85) lextra -> . COMMA insertOpWrite LETRERO letreroPush popIO lextra
    (86) lextra -> . empty
    (132) empty -> .

    COMMA           shift and go to state 223
    RPAREN          reduce using rule 132 (empty -> .)

    lextra                         shift and go to state 250
    empty                          shift and go to state 224

state 226

    (116) f -> LPAREN addFF exp RPAREN . rmFF
    (130) rmFF -> .

    MULT            reduce using rule 130 (rmFF -> .)
    DIV             reduce using rule 130 (rmFF -> .)
    PLUS            reduce using rule 130 (rmFF -> .)
    MINUS           reduce using rule 130 (rmFF -> .)
    LT              reduce using rule 130 (rmFF -> .)
    GT              reduce using rule 130 (rmFF -> .)
    LTE             reduce using rule 130 (rmFF -> .)
    GTE             reduce using rule 130 (rmFF -> .)
    EQUALS          reduce using rule 130 (rmFF -> .)
    NEQUALS         reduce using rule 130 (rmFF -> .)
    AND             reduce using rule 130 (rmFF -> .)
    OR              reduce using rule 130 (rmFF -> .)
    RPAREN          reduce using rule 130 (rmFF -> .)
    COMMA           reduce using rule 130 (rmFF -> .)
    SCOLON          reduce using rule 130 (rmFF -> .)
    TO              reduce using rule 130 (rmFF -> .)
    DO              reduce using rule 130 (rmFF -> .)
    RBRACK          reduce using rule 130 (rmFF -> .)

    rmFF                           shift and go to state 251

state 227

    (89) condicion -> IF LPAREN exp RPAREN cond1 THEN . LBRACE listaEstatutos RBRACE
    (90) condicion -> IF LPAREN exp RPAREN cond1 THEN . LBRACE listaEstatutos RBRACE ELSE cond3 LBRACE listaEstatutos RBRACE

    LBRACE          shift and go to state 252


state 228

    (100) exp -> texp step7 OR pushPoper . exp
    (99) exp -> . texp step7
    (100) exp -> . texp step7 OR pushPoper exp
    (101) texp -> . gexp step6
    (102) texp -> . gexp step6 AND pushPoper texp
    (103) gexp -> . mexp step5
    (104) gexp -> . mexp step5 LT pushPoper gexp
    (105) gexp -> . mexp step5 GT pushPoper gexp
    (106) gexp -> . mexp step5 LTE pushPoper gexp
    (107) gexp -> . mexp step5 GTE pushPoper gexp
    (108) gexp -> . mexp step5 EQUALS pushPoper gexp
    (109) gexp -> . mexp step5 NEQUALS pushPoper gexp
    (110) mexp -> . t step4
    (111) mexp -> . t step4 PLUS pushPoper mexp
    (112) mexp -> . t step4 MINUS pushPoper mexp
    (113) t -> . f step3
    (114) t -> . f step3 MULT pushPoper t
    (115) t -> . f step3 DIV pushPoper t
    (116) f -> . LPAREN addFF exp RPAREN rmFF
    (117) f -> . CTE_I addCteTable step1
    (118) f -> . CTE_F addCteTable step1
    (119) f -> . CTE_C addCteTable step1
    (120) f -> . llamada
    (121) f -> . idCall
    (65) llamada -> . ID DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> . ID verExist LPAREN enviaParam coherenceGo RPAREN
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    LPAREN          shift and go to state 137
    CTE_I           shift and go to state 144
    CTE_F           shift and go to state 145
    CTE_C           shift and go to state 146
    ID              shift and go to state 81

    texp                           shift and go to state 139
    exp                            shift and go to state 253
    gexp                           shift and go to state 140
    mexp                           shift and go to state 141
    t                              shift and go to state 142
    f                              shift and go to state 143
    llamada                        shift and go to state 147
    idCall                         shift and go to state 148

state 229

    (102) texp -> gexp step6 AND pushPoper . texp
    (101) texp -> . gexp step6
    (102) texp -> . gexp step6 AND pushPoper texp
    (103) gexp -> . mexp step5
    (104) gexp -> . mexp step5 LT pushPoper gexp
    (105) gexp -> . mexp step5 GT pushPoper gexp
    (106) gexp -> . mexp step5 LTE pushPoper gexp
    (107) gexp -> . mexp step5 GTE pushPoper gexp
    (108) gexp -> . mexp step5 EQUALS pushPoper gexp
    (109) gexp -> . mexp step5 NEQUALS pushPoper gexp
    (110) mexp -> . t step4
    (111) mexp -> . t step4 PLUS pushPoper mexp
    (112) mexp -> . t step4 MINUS pushPoper mexp
    (113) t -> . f step3
    (114) t -> . f step3 MULT pushPoper t
    (115) t -> . f step3 DIV pushPoper t
    (116) f -> . LPAREN addFF exp RPAREN rmFF
    (117) f -> . CTE_I addCteTable step1
    (118) f -> . CTE_F addCteTable step1
    (119) f -> . CTE_C addCteTable step1
    (120) f -> . llamada
    (121) f -> . idCall
    (65) llamada -> . ID DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> . ID verExist LPAREN enviaParam coherenceGo RPAREN
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    LPAREN          shift and go to state 137
    CTE_I           shift and go to state 144
    CTE_F           shift and go to state 145
    CTE_C           shift and go to state 146
    ID              shift and go to state 81

    gexp                           shift and go to state 140
    texp                           shift and go to state 254
    mexp                           shift and go to state 141
    t                              shift and go to state 142
    f                              shift and go to state 143
    llamada                        shift and go to state 147
    idCall                         shift and go to state 148

state 230

    (104) gexp -> mexp step5 LT pushPoper . gexp
    (103) gexp -> . mexp step5
    (104) gexp -> . mexp step5 LT pushPoper gexp
    (105) gexp -> . mexp step5 GT pushPoper gexp
    (106) gexp -> . mexp step5 LTE pushPoper gexp
    (107) gexp -> . mexp step5 GTE pushPoper gexp
    (108) gexp -> . mexp step5 EQUALS pushPoper gexp
    (109) gexp -> . mexp step5 NEQUALS pushPoper gexp
    (110) mexp -> . t step4
    (111) mexp -> . t step4 PLUS pushPoper mexp
    (112) mexp -> . t step4 MINUS pushPoper mexp
    (113) t -> . f step3
    (114) t -> . f step3 MULT pushPoper t
    (115) t -> . f step3 DIV pushPoper t
    (116) f -> . LPAREN addFF exp RPAREN rmFF
    (117) f -> . CTE_I addCteTable step1
    (118) f -> . CTE_F addCteTable step1
    (119) f -> . CTE_C addCteTable step1
    (120) f -> . llamada
    (121) f -> . idCall
    (65) llamada -> . ID DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> . ID verExist LPAREN enviaParam coherenceGo RPAREN
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    LPAREN          shift and go to state 137
    CTE_I           shift and go to state 144
    CTE_F           shift and go to state 145
    CTE_C           shift and go to state 146
    ID              shift and go to state 81

    mexp                           shift and go to state 141
    gexp                           shift and go to state 255
    t                              shift and go to state 142
    f                              shift and go to state 143
    llamada                        shift and go to state 147
    idCall                         shift and go to state 148

state 231

    (105) gexp -> mexp step5 GT pushPoper . gexp
    (103) gexp -> . mexp step5
    (104) gexp -> . mexp step5 LT pushPoper gexp
    (105) gexp -> . mexp step5 GT pushPoper gexp
    (106) gexp -> . mexp step5 LTE pushPoper gexp
    (107) gexp -> . mexp step5 GTE pushPoper gexp
    (108) gexp -> . mexp step5 EQUALS pushPoper gexp
    (109) gexp -> . mexp step5 NEQUALS pushPoper gexp
    (110) mexp -> . t step4
    (111) mexp -> . t step4 PLUS pushPoper mexp
    (112) mexp -> . t step4 MINUS pushPoper mexp
    (113) t -> . f step3
    (114) t -> . f step3 MULT pushPoper t
    (115) t -> . f step3 DIV pushPoper t
    (116) f -> . LPAREN addFF exp RPAREN rmFF
    (117) f -> . CTE_I addCteTable step1
    (118) f -> . CTE_F addCteTable step1
    (119) f -> . CTE_C addCteTable step1
    (120) f -> . llamada
    (121) f -> . idCall
    (65) llamada -> . ID DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> . ID verExist LPAREN enviaParam coherenceGo RPAREN
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    LPAREN          shift and go to state 137
    CTE_I           shift and go to state 144
    CTE_F           shift and go to state 145
    CTE_C           shift and go to state 146
    ID              shift and go to state 81

    mexp                           shift and go to state 141
    gexp                           shift and go to state 256
    t                              shift and go to state 142
    f                              shift and go to state 143
    llamada                        shift and go to state 147
    idCall                         shift and go to state 148

state 232

    (106) gexp -> mexp step5 LTE pushPoper . gexp
    (103) gexp -> . mexp step5
    (104) gexp -> . mexp step5 LT pushPoper gexp
    (105) gexp -> . mexp step5 GT pushPoper gexp
    (106) gexp -> . mexp step5 LTE pushPoper gexp
    (107) gexp -> . mexp step5 GTE pushPoper gexp
    (108) gexp -> . mexp step5 EQUALS pushPoper gexp
    (109) gexp -> . mexp step5 NEQUALS pushPoper gexp
    (110) mexp -> . t step4
    (111) mexp -> . t step4 PLUS pushPoper mexp
    (112) mexp -> . t step4 MINUS pushPoper mexp
    (113) t -> . f step3
    (114) t -> . f step3 MULT pushPoper t
    (115) t -> . f step3 DIV pushPoper t
    (116) f -> . LPAREN addFF exp RPAREN rmFF
    (117) f -> . CTE_I addCteTable step1
    (118) f -> . CTE_F addCteTable step1
    (119) f -> . CTE_C addCteTable step1
    (120) f -> . llamada
    (121) f -> . idCall
    (65) llamada -> . ID DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> . ID verExist LPAREN enviaParam coherenceGo RPAREN
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    LPAREN          shift and go to state 137
    CTE_I           shift and go to state 144
    CTE_F           shift and go to state 145
    CTE_C           shift and go to state 146
    ID              shift and go to state 81

    mexp                           shift and go to state 141
    gexp                           shift and go to state 257
    t                              shift and go to state 142
    f                              shift and go to state 143
    llamada                        shift and go to state 147
    idCall                         shift and go to state 148

state 233

    (107) gexp -> mexp step5 GTE pushPoper . gexp
    (103) gexp -> . mexp step5
    (104) gexp -> . mexp step5 LT pushPoper gexp
    (105) gexp -> . mexp step5 GT pushPoper gexp
    (106) gexp -> . mexp step5 LTE pushPoper gexp
    (107) gexp -> . mexp step5 GTE pushPoper gexp
    (108) gexp -> . mexp step5 EQUALS pushPoper gexp
    (109) gexp -> . mexp step5 NEQUALS pushPoper gexp
    (110) mexp -> . t step4
    (111) mexp -> . t step4 PLUS pushPoper mexp
    (112) mexp -> . t step4 MINUS pushPoper mexp
    (113) t -> . f step3
    (114) t -> . f step3 MULT pushPoper t
    (115) t -> . f step3 DIV pushPoper t
    (116) f -> . LPAREN addFF exp RPAREN rmFF
    (117) f -> . CTE_I addCteTable step1
    (118) f -> . CTE_F addCteTable step1
    (119) f -> . CTE_C addCteTable step1
    (120) f -> . llamada
    (121) f -> . idCall
    (65) llamada -> . ID DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> . ID verExist LPAREN enviaParam coherenceGo RPAREN
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    LPAREN          shift and go to state 137
    CTE_I           shift and go to state 144
    CTE_F           shift and go to state 145
    CTE_C           shift and go to state 146
    ID              shift and go to state 81

    mexp                           shift and go to state 141
    gexp                           shift and go to state 258
    t                              shift and go to state 142
    f                              shift and go to state 143
    llamada                        shift and go to state 147
    idCall                         shift and go to state 148

state 234

    (108) gexp -> mexp step5 EQUALS pushPoper . gexp
    (103) gexp -> . mexp step5
    (104) gexp -> . mexp step5 LT pushPoper gexp
    (105) gexp -> . mexp step5 GT pushPoper gexp
    (106) gexp -> . mexp step5 LTE pushPoper gexp
    (107) gexp -> . mexp step5 GTE pushPoper gexp
    (108) gexp -> . mexp step5 EQUALS pushPoper gexp
    (109) gexp -> . mexp step5 NEQUALS pushPoper gexp
    (110) mexp -> . t step4
    (111) mexp -> . t step4 PLUS pushPoper mexp
    (112) mexp -> . t step4 MINUS pushPoper mexp
    (113) t -> . f step3
    (114) t -> . f step3 MULT pushPoper t
    (115) t -> . f step3 DIV pushPoper t
    (116) f -> . LPAREN addFF exp RPAREN rmFF
    (117) f -> . CTE_I addCteTable step1
    (118) f -> . CTE_F addCteTable step1
    (119) f -> . CTE_C addCteTable step1
    (120) f -> . llamada
    (121) f -> . idCall
    (65) llamada -> . ID DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> . ID verExist LPAREN enviaParam coherenceGo RPAREN
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    LPAREN          shift and go to state 137
    CTE_I           shift and go to state 144
    CTE_F           shift and go to state 145
    CTE_C           shift and go to state 146
    ID              shift and go to state 81

    mexp                           shift and go to state 141
    gexp                           shift and go to state 259
    t                              shift and go to state 142
    f                              shift and go to state 143
    llamada                        shift and go to state 147
    idCall                         shift and go to state 148

state 235

    (109) gexp -> mexp step5 NEQUALS pushPoper . gexp
    (103) gexp -> . mexp step5
    (104) gexp -> . mexp step5 LT pushPoper gexp
    (105) gexp -> . mexp step5 GT pushPoper gexp
    (106) gexp -> . mexp step5 LTE pushPoper gexp
    (107) gexp -> . mexp step5 GTE pushPoper gexp
    (108) gexp -> . mexp step5 EQUALS pushPoper gexp
    (109) gexp -> . mexp step5 NEQUALS pushPoper gexp
    (110) mexp -> . t step4
    (111) mexp -> . t step4 PLUS pushPoper mexp
    (112) mexp -> . t step4 MINUS pushPoper mexp
    (113) t -> . f step3
    (114) t -> . f step3 MULT pushPoper t
    (115) t -> . f step3 DIV pushPoper t
    (116) f -> . LPAREN addFF exp RPAREN rmFF
    (117) f -> . CTE_I addCteTable step1
    (118) f -> . CTE_F addCteTable step1
    (119) f -> . CTE_C addCteTable step1
    (120) f -> . llamada
    (121) f -> . idCall
    (65) llamada -> . ID DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> . ID verExist LPAREN enviaParam coherenceGo RPAREN
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    LPAREN          shift and go to state 137
    CTE_I           shift and go to state 144
    CTE_F           shift and go to state 145
    CTE_C           shift and go to state 146
    ID              shift and go to state 81

    mexp                           shift and go to state 141
    gexp                           shift and go to state 260
    t                              shift and go to state 142
    f                              shift and go to state 143
    llamada                        shift and go to state 147
    idCall                         shift and go to state 148

state 236

    (111) mexp -> t step4 PLUS pushPoper . mexp
    (110) mexp -> . t step4
    (111) mexp -> . t step4 PLUS pushPoper mexp
    (112) mexp -> . t step4 MINUS pushPoper mexp
    (113) t -> . f step3
    (114) t -> . f step3 MULT pushPoper t
    (115) t -> . f step3 DIV pushPoper t
    (116) f -> . LPAREN addFF exp RPAREN rmFF
    (117) f -> . CTE_I addCteTable step1
    (118) f -> . CTE_F addCteTable step1
    (119) f -> . CTE_C addCteTable step1
    (120) f -> . llamada
    (121) f -> . idCall
    (65) llamada -> . ID DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> . ID verExist LPAREN enviaParam coherenceGo RPAREN
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    LPAREN          shift and go to state 137
    CTE_I           shift and go to state 144
    CTE_F           shift and go to state 145
    CTE_C           shift and go to state 146
    ID              shift and go to state 81

    t                              shift and go to state 142
    mexp                           shift and go to state 261
    f                              shift and go to state 143
    llamada                        shift and go to state 147
    idCall                         shift and go to state 148

state 237

    (112) mexp -> t step4 MINUS pushPoper . mexp
    (110) mexp -> . t step4
    (111) mexp -> . t step4 PLUS pushPoper mexp
    (112) mexp -> . t step4 MINUS pushPoper mexp
    (113) t -> . f step3
    (114) t -> . f step3 MULT pushPoper t
    (115) t -> . f step3 DIV pushPoper t
    (116) f -> . LPAREN addFF exp RPAREN rmFF
    (117) f -> . CTE_I addCteTable step1
    (118) f -> . CTE_F addCteTable step1
    (119) f -> . CTE_C addCteTable step1
    (120) f -> . llamada
    (121) f -> . idCall
    (65) llamada -> . ID DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> . ID verExist LPAREN enviaParam coherenceGo RPAREN
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    LPAREN          shift and go to state 137
    CTE_I           shift and go to state 144
    CTE_F           shift and go to state 145
    CTE_C           shift and go to state 146
    ID              shift and go to state 81

    t                              shift and go to state 142
    mexp                           shift and go to state 262
    f                              shift and go to state 143
    llamada                        shift and go to state 147
    idCall                         shift and go to state 148

state 238

    (114) t -> f step3 MULT pushPoper . t
    (113) t -> . f step3
    (114) t -> . f step3 MULT pushPoper t
    (115) t -> . f step3 DIV pushPoper t
    (116) f -> . LPAREN addFF exp RPAREN rmFF
    (117) f -> . CTE_I addCteTable step1
    (118) f -> . CTE_F addCteTable step1
    (119) f -> . CTE_C addCteTable step1
    (120) f -> . llamada
    (121) f -> . idCall
    (65) llamada -> . ID DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> . ID verExist LPAREN enviaParam coherenceGo RPAREN
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    LPAREN          shift and go to state 137
    CTE_I           shift and go to state 144
    CTE_F           shift and go to state 145
    CTE_C           shift and go to state 146
    ID              shift and go to state 81

    f                              shift and go to state 143
    t                              shift and go to state 263
    llamada                        shift and go to state 147
    idCall                         shift and go to state 148

state 239

    (115) t -> f step3 DIV pushPoper . t
    (113) t -> . f step3
    (114) t -> . f step3 MULT pushPoper t
    (115) t -> . f step3 DIV pushPoper t
    (116) f -> . LPAREN addFF exp RPAREN rmFF
    (117) f -> . CTE_I addCteTable step1
    (118) f -> . CTE_F addCteTable step1
    (119) f -> . CTE_C addCteTable step1
    (120) f -> . llamada
    (121) f -> . idCall
    (65) llamada -> . ID DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> . ID verExist LPAREN enviaParam coherenceGo RPAREN
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    LPAREN          shift and go to state 137
    CTE_I           shift and go to state 144
    CTE_F           shift and go to state 145
    CTE_C           shift and go to state 146
    ID              shift and go to state 81

    f                              shift and go to state 143
    t                              shift and go to state 264
    llamada                        shift and go to state 147
    idCall                         shift and go to state 148

state 240

    (93) cond_w -> WHILE step1While LPAREN exp RPAREN step2While . DO LBRACE listaEstatutos RBRACE step3While

    DO              shift and go to state 265


state 241

    (97) cond_f -> FOR asignacion TO exp step1While step1For . step2While DO LBRACE listaEstatutos RBRACE step3While
    (95) step2While -> .

    DO              reduce using rule 95 (step2While -> .)

    step2While                     shift and go to state 266

state 242

    (48) definFunc -> tipoMethod FUNC ID auxFuncion LPAREN listaParam RPAREN declarVar setDI LBRACE listaEstatutos RBRACE endF . definFunc
    (48) definFunc -> . tipoMethod FUNC ID auxFuncion LPAREN listaParam RPAREN declarVar setDI LBRACE listaEstatutos RBRACE endF definFunc
    (49) definFunc -> . empty
    (36) tipoMethod -> . VOID
    (37) tipoMethod -> . INT
    (38) tipoMethod -> . FLOAT
    (39) tipoMethod -> . CHAR
    (132) empty -> .

    VOID            shift and go to state 25
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    CHAR            shift and go to state 28
    MAIN            reduce using rule 132 (empty -> .)

    tipoMethod                     shift and go to state 23
    definFunc                      shift and go to state 267
    empty                          shift and go to state 24

state 243

    (40) declarMethods -> tipoMethod FUNC ID LPAREN listaParam RPAREN LBRACE listaEstatutos RBRACE . declarMethods
    (40) declarMethods -> . tipoMethod FUNC ID LPAREN listaParam RPAREN LBRACE listaEstatutos RBRACE declarMethods
    (41) declarMethods -> . empty
    (36) tipoMethod -> . VOID
    (37) tipoMethod -> . INT
    (38) tipoMethod -> . FLOAT
    (39) tipoMethod -> . CHAR
    (132) empty -> .

    VOID            shift and go to state 25
    INT             shift and go to state 26
    FLOAT           shift and go to state 27
    CHAR            shift and go to state 28
    RBRACE          reduce using rule 132 (empty -> .)

    tipoMethod                     shift and go to state 60
    declarMethods                  shift and go to state 268
    empty                          shift and go to state 61

state 244

    (70) paramReferencia -> exp paramType COMMA paramCount . paramReferencia
    (69) paramReferencia -> . exp paramType
    (70) paramReferencia -> . exp paramType COMMA paramCount paramReferencia
    (99) exp -> . texp step7
    (100) exp -> . texp step7 OR pushPoper exp
    (101) texp -> . gexp step6
    (102) texp -> . gexp step6 AND pushPoper texp
    (103) gexp -> . mexp step5
    (104) gexp -> . mexp step5 LT pushPoper gexp
    (105) gexp -> . mexp step5 GT pushPoper gexp
    (106) gexp -> . mexp step5 LTE pushPoper gexp
    (107) gexp -> . mexp step5 GTE pushPoper gexp
    (108) gexp -> . mexp step5 EQUALS pushPoper gexp
    (109) gexp -> . mexp step5 NEQUALS pushPoper gexp
    (110) mexp -> . t step4
    (111) mexp -> . t step4 PLUS pushPoper mexp
    (112) mexp -> . t step4 MINUS pushPoper mexp
    (113) t -> . f step3
    (114) t -> . f step3 MULT pushPoper t
    (115) t -> . f step3 DIV pushPoper t
    (116) f -> . LPAREN addFF exp RPAREN rmFF
    (117) f -> . CTE_I addCteTable step1
    (118) f -> . CTE_F addCteTable step1
    (119) f -> . CTE_C addCteTable step1
    (120) f -> . llamada
    (121) f -> . idCall
    (65) llamada -> . ID DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> . ID verExist LPAREN enviaParam coherenceGo RPAREN
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    LPAREN          shift and go to state 137
    CTE_I           shift and go to state 144
    CTE_F           shift and go to state 145
    CTE_C           shift and go to state 146
    ID              shift and go to state 81

    exp                            shift and go to state 158
    paramReferencia                shift and go to state 269
    texp                           shift and go to state 139
    gexp                           shift and go to state 140
    mexp                           shift and go to state 141
    t                              shift and go to state 142
    f                              shift and go to state 143
    llamada                        shift and go to state 147
    idCall                         shift and go to state 148

state 245

    (23) idCall -> ID idCallaux LBRACK addFF exp RBRACK rmFF . idCallaux4 checkDim1
    (28) idCallaux4 -> .

    ASIGNA          reduce using rule 28 (idCallaux4 -> .)
    MULT            reduce using rule 28 (idCallaux4 -> .)
    DIV             reduce using rule 28 (idCallaux4 -> .)
    PLUS            reduce using rule 28 (idCallaux4 -> .)
    MINUS           reduce using rule 28 (idCallaux4 -> .)
    LT              reduce using rule 28 (idCallaux4 -> .)
    GT              reduce using rule 28 (idCallaux4 -> .)
    LTE             reduce using rule 28 (idCallaux4 -> .)
    GTE             reduce using rule 28 (idCallaux4 -> .)
    EQUALS          reduce using rule 28 (idCallaux4 -> .)
    NEQUALS         reduce using rule 28 (idCallaux4 -> .)
    AND             reduce using rule 28 (idCallaux4 -> .)
    OR              reduce using rule 28 (idCallaux4 -> .)
    RPAREN          reduce using rule 28 (idCallaux4 -> .)
    COMMA           reduce using rule 28 (idCallaux4 -> .)
    SCOLON          reduce using rule 28 (idCallaux4 -> .)
    TO              reduce using rule 28 (idCallaux4 -> .)
    DO              reduce using rule 28 (idCallaux4 -> .)
    RBRACK          reduce using rule 28 (idCallaux4 -> .)

    idCallaux4                     shift and go to state 270

state 246

    (24) idCall -> ID idCallaux LBRACK addFF exp idCallaux2 rmFF . COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    COMMA           shift and go to state 271


state 247

    (79) listaId -> idCall COMMA popIO insertOpRead . listaId
    (78) listaId -> . idCall popIO
    (79) listaId -> . idCall COMMA popIO insertOpRead listaId
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    ID              shift and go to state 123

    idCall                         shift and go to state 165
    listaId                        shift and go to state 272

state 248

    (82) escritura -> WRITE pushPoper LPAREN exp popIO lextra RPAREN .

    SCOLON          reduce using rule 82 (escritura -> WRITE pushPoper LPAREN exp popIO lextra RPAREN .)


state 249

    (84) lextra -> COMMA insertOpWrite . exp popIO lextra
    (85) lextra -> COMMA insertOpWrite . LETRERO letreroPush popIO lextra
    (99) exp -> . texp step7
    (100) exp -> . texp step7 OR pushPoper exp
    (101) texp -> . gexp step6
    (102) texp -> . gexp step6 AND pushPoper texp
    (103) gexp -> . mexp step5
    (104) gexp -> . mexp step5 LT pushPoper gexp
    (105) gexp -> . mexp step5 GT pushPoper gexp
    (106) gexp -> . mexp step5 LTE pushPoper gexp
    (107) gexp -> . mexp step5 GTE pushPoper gexp
    (108) gexp -> . mexp step5 EQUALS pushPoper gexp
    (109) gexp -> . mexp step5 NEQUALS pushPoper gexp
    (110) mexp -> . t step4
    (111) mexp -> . t step4 PLUS pushPoper mexp
    (112) mexp -> . t step4 MINUS pushPoper mexp
    (113) t -> . f step3
    (114) t -> . f step3 MULT pushPoper t
    (115) t -> . f step3 DIV pushPoper t
    (116) f -> . LPAREN addFF exp RPAREN rmFF
    (117) f -> . CTE_I addCteTable step1
    (118) f -> . CTE_F addCteTable step1
    (119) f -> . CTE_C addCteTable step1
    (120) f -> . llamada
    (121) f -> . idCall
    (65) llamada -> . ID DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> . ID verExist LPAREN enviaParam coherenceGo RPAREN
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    LETRERO         shift and go to state 274
    LPAREN          shift and go to state 137
    CTE_I           shift and go to state 144
    CTE_F           shift and go to state 145
    CTE_C           shift and go to state 146
    ID              shift and go to state 81

    exp                            shift and go to state 273
    texp                           shift and go to state 139
    gexp                           shift and go to state 140
    mexp                           shift and go to state 141
    t                              shift and go to state 142
    f                              shift and go to state 143
    llamada                        shift and go to state 147
    idCall                         shift and go to state 148

state 250

    (83) escritura -> WRITE pushPoper LPAREN LETRERO letreroPush popIO lextra . RPAREN

    RPAREN          shift and go to state 275


state 251

    (116) f -> LPAREN addFF exp RPAREN rmFF .

    MULT            reduce using rule 116 (f -> LPAREN addFF exp RPAREN rmFF .)
    DIV             reduce using rule 116 (f -> LPAREN addFF exp RPAREN rmFF .)
    PLUS            reduce using rule 116 (f -> LPAREN addFF exp RPAREN rmFF .)
    MINUS           reduce using rule 116 (f -> LPAREN addFF exp RPAREN rmFF .)
    LT              reduce using rule 116 (f -> LPAREN addFF exp RPAREN rmFF .)
    GT              reduce using rule 116 (f -> LPAREN addFF exp RPAREN rmFF .)
    LTE             reduce using rule 116 (f -> LPAREN addFF exp RPAREN rmFF .)
    GTE             reduce using rule 116 (f -> LPAREN addFF exp RPAREN rmFF .)
    EQUALS          reduce using rule 116 (f -> LPAREN addFF exp RPAREN rmFF .)
    NEQUALS         reduce using rule 116 (f -> LPAREN addFF exp RPAREN rmFF .)
    AND             reduce using rule 116 (f -> LPAREN addFF exp RPAREN rmFF .)
    OR              reduce using rule 116 (f -> LPAREN addFF exp RPAREN rmFF .)
    RPAREN          reduce using rule 116 (f -> LPAREN addFF exp RPAREN rmFF .)
    COMMA           reduce using rule 116 (f -> LPAREN addFF exp RPAREN rmFF .)
    SCOLON          reduce using rule 116 (f -> LPAREN addFF exp RPAREN rmFF .)
    TO              reduce using rule 116 (f -> LPAREN addFF exp RPAREN rmFF .)
    DO              reduce using rule 116 (f -> LPAREN addFF exp RPAREN rmFF .)
    RBRACK          reduce using rule 116 (f -> LPAREN addFF exp RPAREN rmFF .)


state 252

    (89) condicion -> IF LPAREN exp RPAREN cond1 THEN LBRACE . listaEstatutos RBRACE
    (90) condicion -> IF LPAREN exp RPAREN cond1 THEN LBRACE . listaEstatutos RBRACE ELSE cond3 LBRACE listaEstatutos RBRACE
    (53) listaEstatutos -> . estatutos listaEstatutos
    (54) listaEstatutos -> . empty
    (55) estatutos -> . llamada SCOLON
    (56) estatutos -> . asignacion SCOLON
    (57) estatutos -> . returnf SCOLON
    (58) estatutos -> . lectura SCOLON
    (59) estatutos -> . escritura SCOLON
    (60) estatutos -> . condicion
    (61) estatutos -> . cond_w
    (62) estatutos -> . cond_f
    (132) empty -> .
    (65) llamada -> . ID DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> . ID verExist LPAREN enviaParam coherenceGo RPAREN
    (63) asignacion -> . idCall ASIGNA pushPoper exp asignStep2
    (75) returnf -> . RETURN pushPoper LPAREN exp RPAREN popReturn
    (77) lectura -> . READ pushPoper LPAREN listaId RPAREN
    (82) escritura -> . WRITE pushPoper LPAREN exp popIO lextra RPAREN
    (83) escritura -> . WRITE pushPoper LPAREN LETRERO letreroPush popIO lextra RPAREN
    (89) condicion -> . IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE
    (90) condicion -> . IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE ELSE cond3 LBRACE listaEstatutos RBRACE
    (93) cond_w -> . WHILE step1While LPAREN exp RPAREN step2While DO LBRACE listaEstatutos RBRACE step3While
    (97) cond_f -> . FOR asignacion TO exp step1While step1For step2While DO LBRACE listaEstatutos RBRACE step3While
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    RBRACE          reduce using rule 132 (empty -> .)
    ID              shift and go to state 81
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    WHILE           shift and go to state 98
    FOR             shift and go to state 99

    listaEstatutos                 shift and go to state 276
    estatutos                      shift and go to state 83
    empty                          shift and go to state 84
    llamada                        shift and go to state 85
    asignacion                     shift and go to state 86
    returnf                        shift and go to state 87
    lectura                        shift and go to state 88
    escritura                      shift and go to state 89
    condicion                      shift and go to state 90
    cond_w                         shift and go to state 91
    cond_f                         shift and go to state 92
    idCall                         shift and go to state 93

state 253

    (100) exp -> texp step7 OR pushPoper exp .

    RPAREN          reduce using rule 100 (exp -> texp step7 OR pushPoper exp .)
    COMMA           reduce using rule 100 (exp -> texp step7 OR pushPoper exp .)
    SCOLON          reduce using rule 100 (exp -> texp step7 OR pushPoper exp .)
    TO              reduce using rule 100 (exp -> texp step7 OR pushPoper exp .)
    DO              reduce using rule 100 (exp -> texp step7 OR pushPoper exp .)
    RBRACK          reduce using rule 100 (exp -> texp step7 OR pushPoper exp .)


state 254

    (102) texp -> gexp step6 AND pushPoper texp .

    OR              reduce using rule 102 (texp -> gexp step6 AND pushPoper texp .)
    RPAREN          reduce using rule 102 (texp -> gexp step6 AND pushPoper texp .)
    COMMA           reduce using rule 102 (texp -> gexp step6 AND pushPoper texp .)
    SCOLON          reduce using rule 102 (texp -> gexp step6 AND pushPoper texp .)
    TO              reduce using rule 102 (texp -> gexp step6 AND pushPoper texp .)
    DO              reduce using rule 102 (texp -> gexp step6 AND pushPoper texp .)
    RBRACK          reduce using rule 102 (texp -> gexp step6 AND pushPoper texp .)


state 255

    (104) gexp -> mexp step5 LT pushPoper gexp .

    AND             reduce using rule 104 (gexp -> mexp step5 LT pushPoper gexp .)
    OR              reduce using rule 104 (gexp -> mexp step5 LT pushPoper gexp .)
    RPAREN          reduce using rule 104 (gexp -> mexp step5 LT pushPoper gexp .)
    COMMA           reduce using rule 104 (gexp -> mexp step5 LT pushPoper gexp .)
    SCOLON          reduce using rule 104 (gexp -> mexp step5 LT pushPoper gexp .)
    TO              reduce using rule 104 (gexp -> mexp step5 LT pushPoper gexp .)
    DO              reduce using rule 104 (gexp -> mexp step5 LT pushPoper gexp .)
    RBRACK          reduce using rule 104 (gexp -> mexp step5 LT pushPoper gexp .)


state 256

    (105) gexp -> mexp step5 GT pushPoper gexp .

    AND             reduce using rule 105 (gexp -> mexp step5 GT pushPoper gexp .)
    OR              reduce using rule 105 (gexp -> mexp step5 GT pushPoper gexp .)
    RPAREN          reduce using rule 105 (gexp -> mexp step5 GT pushPoper gexp .)
    COMMA           reduce using rule 105 (gexp -> mexp step5 GT pushPoper gexp .)
    SCOLON          reduce using rule 105 (gexp -> mexp step5 GT pushPoper gexp .)
    TO              reduce using rule 105 (gexp -> mexp step5 GT pushPoper gexp .)
    DO              reduce using rule 105 (gexp -> mexp step5 GT pushPoper gexp .)
    RBRACK          reduce using rule 105 (gexp -> mexp step5 GT pushPoper gexp .)


state 257

    (106) gexp -> mexp step5 LTE pushPoper gexp .

    AND             reduce using rule 106 (gexp -> mexp step5 LTE pushPoper gexp .)
    OR              reduce using rule 106 (gexp -> mexp step5 LTE pushPoper gexp .)
    RPAREN          reduce using rule 106 (gexp -> mexp step5 LTE pushPoper gexp .)
    COMMA           reduce using rule 106 (gexp -> mexp step5 LTE pushPoper gexp .)
    SCOLON          reduce using rule 106 (gexp -> mexp step5 LTE pushPoper gexp .)
    TO              reduce using rule 106 (gexp -> mexp step5 LTE pushPoper gexp .)
    DO              reduce using rule 106 (gexp -> mexp step5 LTE pushPoper gexp .)
    RBRACK          reduce using rule 106 (gexp -> mexp step5 LTE pushPoper gexp .)


state 258

    (107) gexp -> mexp step5 GTE pushPoper gexp .

    AND             reduce using rule 107 (gexp -> mexp step5 GTE pushPoper gexp .)
    OR              reduce using rule 107 (gexp -> mexp step5 GTE pushPoper gexp .)
    RPAREN          reduce using rule 107 (gexp -> mexp step5 GTE pushPoper gexp .)
    COMMA           reduce using rule 107 (gexp -> mexp step5 GTE pushPoper gexp .)
    SCOLON          reduce using rule 107 (gexp -> mexp step5 GTE pushPoper gexp .)
    TO              reduce using rule 107 (gexp -> mexp step5 GTE pushPoper gexp .)
    DO              reduce using rule 107 (gexp -> mexp step5 GTE pushPoper gexp .)
    RBRACK          reduce using rule 107 (gexp -> mexp step5 GTE pushPoper gexp .)


state 259

    (108) gexp -> mexp step5 EQUALS pushPoper gexp .

    AND             reduce using rule 108 (gexp -> mexp step5 EQUALS pushPoper gexp .)
    OR              reduce using rule 108 (gexp -> mexp step5 EQUALS pushPoper gexp .)
    RPAREN          reduce using rule 108 (gexp -> mexp step5 EQUALS pushPoper gexp .)
    COMMA           reduce using rule 108 (gexp -> mexp step5 EQUALS pushPoper gexp .)
    SCOLON          reduce using rule 108 (gexp -> mexp step5 EQUALS pushPoper gexp .)
    TO              reduce using rule 108 (gexp -> mexp step5 EQUALS pushPoper gexp .)
    DO              reduce using rule 108 (gexp -> mexp step5 EQUALS pushPoper gexp .)
    RBRACK          reduce using rule 108 (gexp -> mexp step5 EQUALS pushPoper gexp .)


state 260

    (109) gexp -> mexp step5 NEQUALS pushPoper gexp .

    AND             reduce using rule 109 (gexp -> mexp step5 NEQUALS pushPoper gexp .)
    OR              reduce using rule 109 (gexp -> mexp step5 NEQUALS pushPoper gexp .)
    RPAREN          reduce using rule 109 (gexp -> mexp step5 NEQUALS pushPoper gexp .)
    COMMA           reduce using rule 109 (gexp -> mexp step5 NEQUALS pushPoper gexp .)
    SCOLON          reduce using rule 109 (gexp -> mexp step5 NEQUALS pushPoper gexp .)
    TO              reduce using rule 109 (gexp -> mexp step5 NEQUALS pushPoper gexp .)
    DO              reduce using rule 109 (gexp -> mexp step5 NEQUALS pushPoper gexp .)
    RBRACK          reduce using rule 109 (gexp -> mexp step5 NEQUALS pushPoper gexp .)


state 261

    (111) mexp -> t step4 PLUS pushPoper mexp .

    LT              reduce using rule 111 (mexp -> t step4 PLUS pushPoper mexp .)
    GT              reduce using rule 111 (mexp -> t step4 PLUS pushPoper mexp .)
    LTE             reduce using rule 111 (mexp -> t step4 PLUS pushPoper mexp .)
    GTE             reduce using rule 111 (mexp -> t step4 PLUS pushPoper mexp .)
    EQUALS          reduce using rule 111 (mexp -> t step4 PLUS pushPoper mexp .)
    NEQUALS         reduce using rule 111 (mexp -> t step4 PLUS pushPoper mexp .)
    AND             reduce using rule 111 (mexp -> t step4 PLUS pushPoper mexp .)
    OR              reduce using rule 111 (mexp -> t step4 PLUS pushPoper mexp .)
    RPAREN          reduce using rule 111 (mexp -> t step4 PLUS pushPoper mexp .)
    COMMA           reduce using rule 111 (mexp -> t step4 PLUS pushPoper mexp .)
    SCOLON          reduce using rule 111 (mexp -> t step4 PLUS pushPoper mexp .)
    TO              reduce using rule 111 (mexp -> t step4 PLUS pushPoper mexp .)
    DO              reduce using rule 111 (mexp -> t step4 PLUS pushPoper mexp .)
    RBRACK          reduce using rule 111 (mexp -> t step4 PLUS pushPoper mexp .)


state 262

    (112) mexp -> t step4 MINUS pushPoper mexp .

    LT              reduce using rule 112 (mexp -> t step4 MINUS pushPoper mexp .)
    GT              reduce using rule 112 (mexp -> t step4 MINUS pushPoper mexp .)
    LTE             reduce using rule 112 (mexp -> t step4 MINUS pushPoper mexp .)
    GTE             reduce using rule 112 (mexp -> t step4 MINUS pushPoper mexp .)
    EQUALS          reduce using rule 112 (mexp -> t step4 MINUS pushPoper mexp .)
    NEQUALS         reduce using rule 112 (mexp -> t step4 MINUS pushPoper mexp .)
    AND             reduce using rule 112 (mexp -> t step4 MINUS pushPoper mexp .)
    OR              reduce using rule 112 (mexp -> t step4 MINUS pushPoper mexp .)
    RPAREN          reduce using rule 112 (mexp -> t step4 MINUS pushPoper mexp .)
    COMMA           reduce using rule 112 (mexp -> t step4 MINUS pushPoper mexp .)
    SCOLON          reduce using rule 112 (mexp -> t step4 MINUS pushPoper mexp .)
    TO              reduce using rule 112 (mexp -> t step4 MINUS pushPoper mexp .)
    DO              reduce using rule 112 (mexp -> t step4 MINUS pushPoper mexp .)
    RBRACK          reduce using rule 112 (mexp -> t step4 MINUS pushPoper mexp .)


state 263

    (114) t -> f step3 MULT pushPoper t .

    PLUS            reduce using rule 114 (t -> f step3 MULT pushPoper t .)
    MINUS           reduce using rule 114 (t -> f step3 MULT pushPoper t .)
    LT              reduce using rule 114 (t -> f step3 MULT pushPoper t .)
    GT              reduce using rule 114 (t -> f step3 MULT pushPoper t .)
    LTE             reduce using rule 114 (t -> f step3 MULT pushPoper t .)
    GTE             reduce using rule 114 (t -> f step3 MULT pushPoper t .)
    EQUALS          reduce using rule 114 (t -> f step3 MULT pushPoper t .)
    NEQUALS         reduce using rule 114 (t -> f step3 MULT pushPoper t .)
    AND             reduce using rule 114 (t -> f step3 MULT pushPoper t .)
    OR              reduce using rule 114 (t -> f step3 MULT pushPoper t .)
    RPAREN          reduce using rule 114 (t -> f step3 MULT pushPoper t .)
    COMMA           reduce using rule 114 (t -> f step3 MULT pushPoper t .)
    SCOLON          reduce using rule 114 (t -> f step3 MULT pushPoper t .)
    TO              reduce using rule 114 (t -> f step3 MULT pushPoper t .)
    DO              reduce using rule 114 (t -> f step3 MULT pushPoper t .)
    RBRACK          reduce using rule 114 (t -> f step3 MULT pushPoper t .)


state 264

    (115) t -> f step3 DIV pushPoper t .

    PLUS            reduce using rule 115 (t -> f step3 DIV pushPoper t .)
    MINUS           reduce using rule 115 (t -> f step3 DIV pushPoper t .)
    LT              reduce using rule 115 (t -> f step3 DIV pushPoper t .)
    GT              reduce using rule 115 (t -> f step3 DIV pushPoper t .)
    LTE             reduce using rule 115 (t -> f step3 DIV pushPoper t .)
    GTE             reduce using rule 115 (t -> f step3 DIV pushPoper t .)
    EQUALS          reduce using rule 115 (t -> f step3 DIV pushPoper t .)
    NEQUALS         reduce using rule 115 (t -> f step3 DIV pushPoper t .)
    AND             reduce using rule 115 (t -> f step3 DIV pushPoper t .)
    OR              reduce using rule 115 (t -> f step3 DIV pushPoper t .)
    RPAREN          reduce using rule 115 (t -> f step3 DIV pushPoper t .)
    COMMA           reduce using rule 115 (t -> f step3 DIV pushPoper t .)
    SCOLON          reduce using rule 115 (t -> f step3 DIV pushPoper t .)
    TO              reduce using rule 115 (t -> f step3 DIV pushPoper t .)
    DO              reduce using rule 115 (t -> f step3 DIV pushPoper t .)
    RBRACK          reduce using rule 115 (t -> f step3 DIV pushPoper t .)


state 265

    (93) cond_w -> WHILE step1While LPAREN exp RPAREN step2While DO . LBRACE listaEstatutos RBRACE step3While

    LBRACE          shift and go to state 277


state 266

    (97) cond_f -> FOR asignacion TO exp step1While step1For step2While . DO LBRACE listaEstatutos RBRACE step3While

    DO              shift and go to state 278


state 267

    (48) definFunc -> tipoMethod FUNC ID auxFuncion LPAREN listaParam RPAREN declarVar setDI LBRACE listaEstatutos RBRACE endF definFunc .

    MAIN            reduce using rule 48 (definFunc -> tipoMethod FUNC ID auxFuncion LPAREN listaParam RPAREN declarVar setDI LBRACE listaEstatutos RBRACE endF definFunc .)


state 268

    (40) declarMethods -> tipoMethod FUNC ID LPAREN listaParam RPAREN LBRACE listaEstatutos RBRACE declarMethods .

    RBRACE          reduce using rule 40 (declarMethods -> tipoMethod FUNC ID LPAREN listaParam RPAREN LBRACE listaEstatutos RBRACE declarMethods .)


state 269

    (70) paramReferencia -> exp paramType COMMA paramCount paramReferencia .

    RPAREN          reduce using rule 70 (paramReferencia -> exp paramType COMMA paramCount paramReferencia .)


state 270

    (23) idCall -> ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 . checkDim1
    (30) checkDim1 -> .

    ASIGNA          reduce using rule 30 (checkDim1 -> .)
    MULT            reduce using rule 30 (checkDim1 -> .)
    DIV             reduce using rule 30 (checkDim1 -> .)
    PLUS            reduce using rule 30 (checkDim1 -> .)
    MINUS           reduce using rule 30 (checkDim1 -> .)
    LT              reduce using rule 30 (checkDim1 -> .)
    GT              reduce using rule 30 (checkDim1 -> .)
    LTE             reduce using rule 30 (checkDim1 -> .)
    GTE             reduce using rule 30 (checkDim1 -> .)
    EQUALS          reduce using rule 30 (checkDim1 -> .)
    NEQUALS         reduce using rule 30 (checkDim1 -> .)
    AND             reduce using rule 30 (checkDim1 -> .)
    OR              reduce using rule 30 (checkDim1 -> .)
    RPAREN          reduce using rule 30 (checkDim1 -> .)
    COMMA           reduce using rule 30 (checkDim1 -> .)
    SCOLON          reduce using rule 30 (checkDim1 -> .)
    TO              reduce using rule 30 (checkDim1 -> .)
    DO              reduce using rule 30 (checkDim1 -> .)
    RBRACK          reduce using rule 30 (checkDim1 -> .)

    checkDim1                      shift and go to state 279

state 271

    (24) idCall -> ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA . addFF exp idCallaux3 RBRACK rmFF checkDim2
    (129) addFF -> .

    LPAREN          reduce using rule 129 (addFF -> .)
    CTE_I           reduce using rule 129 (addFF -> .)
    CTE_F           reduce using rule 129 (addFF -> .)
    CTE_C           reduce using rule 129 (addFF -> .)
    ID              reduce using rule 129 (addFF -> .)

    addFF                          shift and go to state 280

state 272

    (79) listaId -> idCall COMMA popIO insertOpRead listaId .

    RPAREN          reduce using rule 79 (listaId -> idCall COMMA popIO insertOpRead listaId .)


state 273

    (84) lextra -> COMMA insertOpWrite exp . popIO lextra
    (81) popIO -> .

    COMMA           reduce using rule 81 (popIO -> .)
    RPAREN          reduce using rule 81 (popIO -> .)

    popIO                          shift and go to state 281

state 274

    (85) lextra -> COMMA insertOpWrite LETRERO . letreroPush popIO lextra
    (88) letreroPush -> .

    COMMA           reduce using rule 88 (letreroPush -> .)
    RPAREN          reduce using rule 88 (letreroPush -> .)

    letreroPush                    shift and go to state 282

state 275

    (83) escritura -> WRITE pushPoper LPAREN LETRERO letreroPush popIO lextra RPAREN .

    SCOLON          reduce using rule 83 (escritura -> WRITE pushPoper LPAREN LETRERO letreroPush popIO lextra RPAREN .)


state 276

    (89) condicion -> IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos . RBRACE
    (90) condicion -> IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos . RBRACE ELSE cond3 LBRACE listaEstatutos RBRACE

    RBRACE          shift and go to state 283


state 277

    (93) cond_w -> WHILE step1While LPAREN exp RPAREN step2While DO LBRACE . listaEstatutos RBRACE step3While
    (53) listaEstatutos -> . estatutos listaEstatutos
    (54) listaEstatutos -> . empty
    (55) estatutos -> . llamada SCOLON
    (56) estatutos -> . asignacion SCOLON
    (57) estatutos -> . returnf SCOLON
    (58) estatutos -> . lectura SCOLON
    (59) estatutos -> . escritura SCOLON
    (60) estatutos -> . condicion
    (61) estatutos -> . cond_w
    (62) estatutos -> . cond_f
    (132) empty -> .
    (65) llamada -> . ID DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> . ID verExist LPAREN enviaParam coherenceGo RPAREN
    (63) asignacion -> . idCall ASIGNA pushPoper exp asignStep2
    (75) returnf -> . RETURN pushPoper LPAREN exp RPAREN popReturn
    (77) lectura -> . READ pushPoper LPAREN listaId RPAREN
    (82) escritura -> . WRITE pushPoper LPAREN exp popIO lextra RPAREN
    (83) escritura -> . WRITE pushPoper LPAREN LETRERO letreroPush popIO lextra RPAREN
    (89) condicion -> . IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE
    (90) condicion -> . IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE ELSE cond3 LBRACE listaEstatutos RBRACE
    (93) cond_w -> . WHILE step1While LPAREN exp RPAREN step2While DO LBRACE listaEstatutos RBRACE step3While
    (97) cond_f -> . FOR asignacion TO exp step1While step1For step2While DO LBRACE listaEstatutos RBRACE step3While
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    RBRACE          reduce using rule 132 (empty -> .)
    ID              shift and go to state 81
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    WHILE           shift and go to state 98
    FOR             shift and go to state 99

    listaEstatutos                 shift and go to state 284
    estatutos                      shift and go to state 83
    empty                          shift and go to state 84
    llamada                        shift and go to state 85
    asignacion                     shift and go to state 86
    returnf                        shift and go to state 87
    lectura                        shift and go to state 88
    escritura                      shift and go to state 89
    condicion                      shift and go to state 90
    cond_w                         shift and go to state 91
    cond_f                         shift and go to state 92
    idCall                         shift and go to state 93

state 278

    (97) cond_f -> FOR asignacion TO exp step1While step1For step2While DO . LBRACE listaEstatutos RBRACE step3While

    LBRACE          shift and go to state 285


state 279

    (23) idCall -> ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1 .

    ASIGNA          reduce using rule 23 (idCall -> ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1 .)
    MULT            reduce using rule 23 (idCall -> ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1 .)
    DIV             reduce using rule 23 (idCall -> ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1 .)
    PLUS            reduce using rule 23 (idCall -> ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1 .)
    MINUS           reduce using rule 23 (idCall -> ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1 .)
    LT              reduce using rule 23 (idCall -> ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1 .)
    GT              reduce using rule 23 (idCall -> ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1 .)
    LTE             reduce using rule 23 (idCall -> ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1 .)
    GTE             reduce using rule 23 (idCall -> ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1 .)
    EQUALS          reduce using rule 23 (idCall -> ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1 .)
    NEQUALS         reduce using rule 23 (idCall -> ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1 .)
    AND             reduce using rule 23 (idCall -> ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1 .)
    OR              reduce using rule 23 (idCall -> ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1 .)
    RPAREN          reduce using rule 23 (idCall -> ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1 .)
    COMMA           reduce using rule 23 (idCall -> ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1 .)
    SCOLON          reduce using rule 23 (idCall -> ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1 .)
    TO              reduce using rule 23 (idCall -> ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1 .)
    DO              reduce using rule 23 (idCall -> ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1 .)
    RBRACK          reduce using rule 23 (idCall -> ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1 .)


state 280

    (24) idCall -> ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF . exp idCallaux3 RBRACK rmFF checkDim2
    (99) exp -> . texp step7
    (100) exp -> . texp step7 OR pushPoper exp
    (101) texp -> . gexp step6
    (102) texp -> . gexp step6 AND pushPoper texp
    (103) gexp -> . mexp step5
    (104) gexp -> . mexp step5 LT pushPoper gexp
    (105) gexp -> . mexp step5 GT pushPoper gexp
    (106) gexp -> . mexp step5 LTE pushPoper gexp
    (107) gexp -> . mexp step5 GTE pushPoper gexp
    (108) gexp -> . mexp step5 EQUALS pushPoper gexp
    (109) gexp -> . mexp step5 NEQUALS pushPoper gexp
    (110) mexp -> . t step4
    (111) mexp -> . t step4 PLUS pushPoper mexp
    (112) mexp -> . t step4 MINUS pushPoper mexp
    (113) t -> . f step3
    (114) t -> . f step3 MULT pushPoper t
    (115) t -> . f step3 DIV pushPoper t
    (116) f -> . LPAREN addFF exp RPAREN rmFF
    (117) f -> . CTE_I addCteTable step1
    (118) f -> . CTE_F addCteTable step1
    (119) f -> . CTE_C addCteTable step1
    (120) f -> . llamada
    (121) f -> . idCall
    (65) llamada -> . ID DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> . ID verExist LPAREN enviaParam coherenceGo RPAREN
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    LPAREN          shift and go to state 137
    CTE_I           shift and go to state 144
    CTE_F           shift and go to state 145
    CTE_C           shift and go to state 146
    ID              shift and go to state 81

    exp                            shift and go to state 286
    texp                           shift and go to state 139
    gexp                           shift and go to state 140
    mexp                           shift and go to state 141
    t                              shift and go to state 142
    f                              shift and go to state 143
    llamada                        shift and go to state 147
    idCall                         shift and go to state 148

state 281

    (84) lextra -> COMMA insertOpWrite exp popIO . lextra
    (84) lextra -> . COMMA insertOpWrite exp popIO lextra
    (85) lextra -> . COMMA insertOpWrite LETRERO letreroPush popIO lextra
    (86) lextra -> . empty
    (132) empty -> .

    COMMA           shift and go to state 223
    RPAREN          reduce using rule 132 (empty -> .)

    lextra                         shift and go to state 287
    empty                          shift and go to state 224

state 282

    (85) lextra -> COMMA insertOpWrite LETRERO letreroPush . popIO lextra
    (81) popIO -> .

    COMMA           reduce using rule 81 (popIO -> .)
    RPAREN          reduce using rule 81 (popIO -> .)

    popIO                          shift and go to state 288

state 283

    (89) condicion -> IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE .
    (90) condicion -> IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE . ELSE cond3 LBRACE listaEstatutos RBRACE

    ID              reduce using rule 89 (condicion -> IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE .)
    RETURN          reduce using rule 89 (condicion -> IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE .)
    READ            reduce using rule 89 (condicion -> IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE .)
    WRITE           reduce using rule 89 (condicion -> IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE .)
    IF              reduce using rule 89 (condicion -> IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE .)
    WHILE           reduce using rule 89 (condicion -> IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE .)
    FOR             reduce using rule 89 (condicion -> IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE .)
    RBRACE          reduce using rule 89 (condicion -> IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE .)
    ELSE            shift and go to state 289


state 284

    (93) cond_w -> WHILE step1While LPAREN exp RPAREN step2While DO LBRACE listaEstatutos . RBRACE step3While

    RBRACE          shift and go to state 290


state 285

    (97) cond_f -> FOR asignacion TO exp step1While step1For step2While DO LBRACE . listaEstatutos RBRACE step3While
    (53) listaEstatutos -> . estatutos listaEstatutos
    (54) listaEstatutos -> . empty
    (55) estatutos -> . llamada SCOLON
    (56) estatutos -> . asignacion SCOLON
    (57) estatutos -> . returnf SCOLON
    (58) estatutos -> . lectura SCOLON
    (59) estatutos -> . escritura SCOLON
    (60) estatutos -> . condicion
    (61) estatutos -> . cond_w
    (62) estatutos -> . cond_f
    (132) empty -> .
    (65) llamada -> . ID DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> . ID verExist LPAREN enviaParam coherenceGo RPAREN
    (63) asignacion -> . idCall ASIGNA pushPoper exp asignStep2
    (75) returnf -> . RETURN pushPoper LPAREN exp RPAREN popReturn
    (77) lectura -> . READ pushPoper LPAREN listaId RPAREN
    (82) escritura -> . WRITE pushPoper LPAREN exp popIO lextra RPAREN
    (83) escritura -> . WRITE pushPoper LPAREN LETRERO letreroPush popIO lextra RPAREN
    (89) condicion -> . IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE
    (90) condicion -> . IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE ELSE cond3 LBRACE listaEstatutos RBRACE
    (93) cond_w -> . WHILE step1While LPAREN exp RPAREN step2While DO LBRACE listaEstatutos RBRACE step3While
    (97) cond_f -> . FOR asignacion TO exp step1While step1For step2While DO LBRACE listaEstatutos RBRACE step3While
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    RBRACE          reduce using rule 132 (empty -> .)
    ID              shift and go to state 81
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    WHILE           shift and go to state 98
    FOR             shift and go to state 99

    asignacion                     shift and go to state 86
    listaEstatutos                 shift and go to state 291
    estatutos                      shift and go to state 83
    empty                          shift and go to state 84
    llamada                        shift and go to state 85
    returnf                        shift and go to state 87
    lectura                        shift and go to state 88
    escritura                      shift and go to state 89
    condicion                      shift and go to state 90
    cond_w                         shift and go to state 91
    cond_f                         shift and go to state 92
    idCall                         shift and go to state 93

state 286

    (24) idCall -> ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp . idCallaux3 RBRACK rmFF checkDim2
    (27) idCallaux3 -> .

    RBRACK          reduce using rule 27 (idCallaux3 -> .)

    idCallaux3                     shift and go to state 292

state 287

    (84) lextra -> COMMA insertOpWrite exp popIO lextra .

    RPAREN          reduce using rule 84 (lextra -> COMMA insertOpWrite exp popIO lextra .)


state 288

    (85) lextra -> COMMA insertOpWrite LETRERO letreroPush popIO . lextra
    (84) lextra -> . COMMA insertOpWrite exp popIO lextra
    (85) lextra -> . COMMA insertOpWrite LETRERO letreroPush popIO lextra
    (86) lextra -> . empty
    (132) empty -> .

    COMMA           shift and go to state 223
    RPAREN          reduce using rule 132 (empty -> .)

    lextra                         shift and go to state 293
    empty                          shift and go to state 224

state 289

    (90) condicion -> IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE ELSE . cond3 LBRACE listaEstatutos RBRACE
    (92) cond3 -> .

    LBRACE          reduce using rule 92 (cond3 -> .)

    cond3                          shift and go to state 294

state 290

    (93) cond_w -> WHILE step1While LPAREN exp RPAREN step2While DO LBRACE listaEstatutos RBRACE . step3While
    (96) step3While -> .

    ID              reduce using rule 96 (step3While -> .)
    RETURN          reduce using rule 96 (step3While -> .)
    READ            reduce using rule 96 (step3While -> .)
    WRITE           reduce using rule 96 (step3While -> .)
    IF              reduce using rule 96 (step3While -> .)
    WHILE           reduce using rule 96 (step3While -> .)
    FOR             reduce using rule 96 (step3While -> .)
    RBRACE          reduce using rule 96 (step3While -> .)

    step3While                     shift and go to state 295

state 291

    (97) cond_f -> FOR asignacion TO exp step1While step1For step2While DO LBRACE listaEstatutos . RBRACE step3While

    RBRACE          shift and go to state 296


state 292

    (24) idCall -> ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 . RBRACK rmFF checkDim2

    RBRACK          shift and go to state 297


state 293

    (85) lextra -> COMMA insertOpWrite LETRERO letreroPush popIO lextra .

    RPAREN          reduce using rule 85 (lextra -> COMMA insertOpWrite LETRERO letreroPush popIO lextra .)


state 294

    (90) condicion -> IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE ELSE cond3 . LBRACE listaEstatutos RBRACE

    LBRACE          shift and go to state 298


state 295

    (93) cond_w -> WHILE step1While LPAREN exp RPAREN step2While DO LBRACE listaEstatutos RBRACE step3While .

    ID              reduce using rule 93 (cond_w -> WHILE step1While LPAREN exp RPAREN step2While DO LBRACE listaEstatutos RBRACE step3While .)
    RETURN          reduce using rule 93 (cond_w -> WHILE step1While LPAREN exp RPAREN step2While DO LBRACE listaEstatutos RBRACE step3While .)
    READ            reduce using rule 93 (cond_w -> WHILE step1While LPAREN exp RPAREN step2While DO LBRACE listaEstatutos RBRACE step3While .)
    WRITE           reduce using rule 93 (cond_w -> WHILE step1While LPAREN exp RPAREN step2While DO LBRACE listaEstatutos RBRACE step3While .)
    IF              reduce using rule 93 (cond_w -> WHILE step1While LPAREN exp RPAREN step2While DO LBRACE listaEstatutos RBRACE step3While .)
    WHILE           reduce using rule 93 (cond_w -> WHILE step1While LPAREN exp RPAREN step2While DO LBRACE listaEstatutos RBRACE step3While .)
    FOR             reduce using rule 93 (cond_w -> WHILE step1While LPAREN exp RPAREN step2While DO LBRACE listaEstatutos RBRACE step3While .)
    RBRACE          reduce using rule 93 (cond_w -> WHILE step1While LPAREN exp RPAREN step2While DO LBRACE listaEstatutos RBRACE step3While .)


state 296

    (97) cond_f -> FOR asignacion TO exp step1While step1For step2While DO LBRACE listaEstatutos RBRACE . step3While
    (96) step3While -> .

    ID              reduce using rule 96 (step3While -> .)
    RETURN          reduce using rule 96 (step3While -> .)
    READ            reduce using rule 96 (step3While -> .)
    WRITE           reduce using rule 96 (step3While -> .)
    IF              reduce using rule 96 (step3While -> .)
    WHILE           reduce using rule 96 (step3While -> .)
    FOR             reduce using rule 96 (step3While -> .)
    RBRACE          reduce using rule 96 (step3While -> .)

    step3While                     shift and go to state 299

state 297

    (24) idCall -> ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK . rmFF checkDim2
    (130) rmFF -> .

    ASIGNA          reduce using rule 130 (rmFF -> .)
    MULT            reduce using rule 130 (rmFF -> .)
    DIV             reduce using rule 130 (rmFF -> .)
    PLUS            reduce using rule 130 (rmFF -> .)
    MINUS           reduce using rule 130 (rmFF -> .)
    LT              reduce using rule 130 (rmFF -> .)
    GT              reduce using rule 130 (rmFF -> .)
    LTE             reduce using rule 130 (rmFF -> .)
    GTE             reduce using rule 130 (rmFF -> .)
    EQUALS          reduce using rule 130 (rmFF -> .)
    NEQUALS         reduce using rule 130 (rmFF -> .)
    AND             reduce using rule 130 (rmFF -> .)
    OR              reduce using rule 130 (rmFF -> .)
    RPAREN          reduce using rule 130 (rmFF -> .)
    COMMA           reduce using rule 130 (rmFF -> .)
    SCOLON          reduce using rule 130 (rmFF -> .)
    TO              reduce using rule 130 (rmFF -> .)
    DO              reduce using rule 130 (rmFF -> .)
    RBRACK          reduce using rule 130 (rmFF -> .)

    rmFF                           shift and go to state 300

state 298

    (90) condicion -> IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE ELSE cond3 LBRACE . listaEstatutos RBRACE
    (53) listaEstatutos -> . estatutos listaEstatutos
    (54) listaEstatutos -> . empty
    (55) estatutos -> . llamada SCOLON
    (56) estatutos -> . asignacion SCOLON
    (57) estatutos -> . returnf SCOLON
    (58) estatutos -> . lectura SCOLON
    (59) estatutos -> . escritura SCOLON
    (60) estatutos -> . condicion
    (61) estatutos -> . cond_w
    (62) estatutos -> . cond_f
    (132) empty -> .
    (65) llamada -> . ID DOT ID LPAREN enviaParam RPAREN
    (66) llamada -> . ID verExist LPAREN enviaParam coherenceGo RPAREN
    (63) asignacion -> . idCall ASIGNA pushPoper exp asignStep2
    (75) returnf -> . RETURN pushPoper LPAREN exp RPAREN popReturn
    (77) lectura -> . READ pushPoper LPAREN listaId RPAREN
    (82) escritura -> . WRITE pushPoper LPAREN exp popIO lextra RPAREN
    (83) escritura -> . WRITE pushPoper LPAREN LETRERO letreroPush popIO lextra RPAREN
    (89) condicion -> . IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE
    (90) condicion -> . IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE ELSE cond3 LBRACE listaEstatutos RBRACE
    (93) cond_w -> . WHILE step1While LPAREN exp RPAREN step2While DO LBRACE listaEstatutos RBRACE step3While
    (97) cond_f -> . FOR asignacion TO exp step1While step1For step2While DO LBRACE listaEstatutos RBRACE step3While
    (21) idCall -> . ID idCallaux checkDim
    (22) idCall -> . ID idCallaux DOT ID
    (23) idCall -> . ID idCallaux LBRACK addFF exp RBRACK rmFF idCallaux4 checkDim1
    (24) idCall -> . ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2

    RBRACE          reduce using rule 132 (empty -> .)
    ID              shift and go to state 81
    RETURN          shift and go to state 94
    READ            shift and go to state 95
    WRITE           shift and go to state 96
    IF              shift and go to state 97
    WHILE           shift and go to state 98
    FOR             shift and go to state 99

    listaEstatutos                 shift and go to state 301
    estatutos                      shift and go to state 83
    empty                          shift and go to state 84
    llamada                        shift and go to state 85
    asignacion                     shift and go to state 86
    returnf                        shift and go to state 87
    lectura                        shift and go to state 88
    escritura                      shift and go to state 89
    condicion                      shift and go to state 90
    cond_w                         shift and go to state 91
    cond_f                         shift and go to state 92
    idCall                         shift and go to state 93

state 299

    (97) cond_f -> FOR asignacion TO exp step1While step1For step2While DO LBRACE listaEstatutos RBRACE step3While .

    ID              reduce using rule 97 (cond_f -> FOR asignacion TO exp step1While step1For step2While DO LBRACE listaEstatutos RBRACE step3While .)
    RETURN          reduce using rule 97 (cond_f -> FOR asignacion TO exp step1While step1For step2While DO LBRACE listaEstatutos RBRACE step3While .)
    READ            reduce using rule 97 (cond_f -> FOR asignacion TO exp step1While step1For step2While DO LBRACE listaEstatutos RBRACE step3While .)
    WRITE           reduce using rule 97 (cond_f -> FOR asignacion TO exp step1While step1For step2While DO LBRACE listaEstatutos RBRACE step3While .)
    IF              reduce using rule 97 (cond_f -> FOR asignacion TO exp step1While step1For step2While DO LBRACE listaEstatutos RBRACE step3While .)
    WHILE           reduce using rule 97 (cond_f -> FOR asignacion TO exp step1While step1For step2While DO LBRACE listaEstatutos RBRACE step3While .)
    FOR             reduce using rule 97 (cond_f -> FOR asignacion TO exp step1While step1For step2While DO LBRACE listaEstatutos RBRACE step3While .)
    RBRACE          reduce using rule 97 (cond_f -> FOR asignacion TO exp step1While step1For step2While DO LBRACE listaEstatutos RBRACE step3While .)


state 300

    (24) idCall -> ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF . checkDim2
    (31) checkDim2 -> .

    ASIGNA          reduce using rule 31 (checkDim2 -> .)
    MULT            reduce using rule 31 (checkDim2 -> .)
    DIV             reduce using rule 31 (checkDim2 -> .)
    PLUS            reduce using rule 31 (checkDim2 -> .)
    MINUS           reduce using rule 31 (checkDim2 -> .)
    LT              reduce using rule 31 (checkDim2 -> .)
    GT              reduce using rule 31 (checkDim2 -> .)
    LTE             reduce using rule 31 (checkDim2 -> .)
    GTE             reduce using rule 31 (checkDim2 -> .)
    EQUALS          reduce using rule 31 (checkDim2 -> .)
    NEQUALS         reduce using rule 31 (checkDim2 -> .)
    AND             reduce using rule 31 (checkDim2 -> .)
    OR              reduce using rule 31 (checkDim2 -> .)
    RPAREN          reduce using rule 31 (checkDim2 -> .)
    COMMA           reduce using rule 31 (checkDim2 -> .)
    SCOLON          reduce using rule 31 (checkDim2 -> .)
    TO              reduce using rule 31 (checkDim2 -> .)
    DO              reduce using rule 31 (checkDim2 -> .)
    RBRACK          reduce using rule 31 (checkDim2 -> .)

    checkDim2                      shift and go to state 302

state 301

    (90) condicion -> IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE ELSE cond3 LBRACE listaEstatutos . RBRACE

    RBRACE          shift and go to state 303


state 302

    (24) idCall -> ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2 .

    ASIGNA          reduce using rule 24 (idCall -> ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2 .)
    MULT            reduce using rule 24 (idCall -> ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2 .)
    DIV             reduce using rule 24 (idCall -> ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2 .)
    PLUS            reduce using rule 24 (idCall -> ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2 .)
    MINUS           reduce using rule 24 (idCall -> ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2 .)
    LT              reduce using rule 24 (idCall -> ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2 .)
    GT              reduce using rule 24 (idCall -> ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2 .)
    LTE             reduce using rule 24 (idCall -> ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2 .)
    GTE             reduce using rule 24 (idCall -> ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2 .)
    EQUALS          reduce using rule 24 (idCall -> ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2 .)
    NEQUALS         reduce using rule 24 (idCall -> ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2 .)
    AND             reduce using rule 24 (idCall -> ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2 .)
    OR              reduce using rule 24 (idCall -> ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2 .)
    RPAREN          reduce using rule 24 (idCall -> ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2 .)
    COMMA           reduce using rule 24 (idCall -> ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2 .)
    SCOLON          reduce using rule 24 (idCall -> ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2 .)
    TO              reduce using rule 24 (idCall -> ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2 .)
    DO              reduce using rule 24 (idCall -> ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2 .)
    RBRACK          reduce using rule 24 (idCall -> ID idCallaux LBRACK addFF exp idCallaux2 rmFF COMMA addFF exp idCallaux3 RBRACK rmFF checkDim2 .)


state 303

    (90) condicion -> IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE ELSE cond3 LBRACE listaEstatutos RBRACE .

    ID              reduce using rule 90 (condicion -> IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE ELSE cond3 LBRACE listaEstatutos RBRACE .)
    RETURN          reduce using rule 90 (condicion -> IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE ELSE cond3 LBRACE listaEstatutos RBRACE .)
    READ            reduce using rule 90 (condicion -> IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE ELSE cond3 LBRACE listaEstatutos RBRACE .)
    WRITE           reduce using rule 90 (condicion -> IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE ELSE cond3 LBRACE listaEstatutos RBRACE .)
    IF              reduce using rule 90 (condicion -> IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE ELSE cond3 LBRACE listaEstatutos RBRACE .)
    WHILE           reduce using rule 90 (condicion -> IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE ELSE cond3 LBRACE listaEstatutos RBRACE .)
    FOR             reduce using rule 90 (condicion -> IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE ELSE cond3 LBRACE listaEstatutos RBRACE .)
    RBRACE          reduce using rule 90 (condicion -> IF LPAREN exp RPAREN cond1 THEN LBRACE listaEstatutos RBRACE ELSE cond3 LBRACE listaEstatutos RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for DOT in state 81 resolved as shift
